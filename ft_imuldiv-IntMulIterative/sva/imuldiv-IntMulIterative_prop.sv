// This property file was autogenerated by AutoSVA on 2024-04-21
// to check the behavior of the original RTL module, whose interface is described below: 

//(mulreq_msg_a[WIDTH-1] ^ mulreq_msg_b[WIDTH-1]) ? (~((mulreq_msg_a[WIDTH-1] ? ~mulreq_msg_a + 1'b1 : mulreq_msg_a) * (mulreq_msg_b[WIDTH-1] ? ~mulreq_msg_b + 1'b1 : mulreq_msg_b)) + 1'b1) : ((mulreq_msg_a[WIDTH-1] ? ~mulreq_msg_a + 1'b1 : mulreq_msg_a) * (mulreq_msg_b[WIDTH-1] ? ~mulreq_msg_b + 1'b1 : mulreq_msg_b))

module imuldiv_IntMulIterative_prop
#(
		parameter ASSERT_INPUTS = 0, parameter WIDTH = 4)
(
		input                clk,
		input                reset,
		
		input  [WIDTH-1:0] mulreq_msg_a,
		input  [WIDTH-1:0] mulreq_msg_b,
		input         mulreq_val,
		input         mulreq_rdy, //output
		
		input  [2*WIDTH-1:0] mulresp_msg_result, //output
		input         mulresp_val, //output
		input         mulresp_rdy
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (reset);

// Re-defined wires 
wire [2*WIDTH-1:0] mulreq_data;
wire mulreq_transid;
wire [2*WIDTH-1:0] mulresp_data;
wire mulresp_transid;

// Symbolics and Handshake signals
wire [0:0] symb_mulreq_transid;
am__symb_mulreq_transid_stable: assume property($stable(symb_mulreq_transid));
wire mulresp_hsk = mulresp_val && mulresp_rdy;
wire mulreq_hsk = mulreq_val && mulreq_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for mulreq_trans
if (ASSERT_INPUTS) begin
	as__mulreq_trans_fairness: assert property (mulresp_val |-> s_eventually(mulresp_rdy));
end else begin
	am__mulreq_trans_fairness: assume property (mulresp_val |-> s_eventually(mulresp_rdy));
end

// Generate sampling signals and model
reg [3:0] mulreq_trans_transid_sampled;
wire mulreq_trans_transid_set = mulreq_hsk && mulreq_transid == symb_mulreq_transid;
wire mulreq_trans_transid_response = mulresp_hsk && mulresp_transid == symb_mulreq_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		mulreq_trans_transid_sampled <= '0;
	end else if (mulreq_trans_transid_set || mulreq_trans_transid_response ) begin
		mulreq_trans_transid_sampled <= mulreq_trans_transid_sampled + mulreq_trans_transid_set - mulreq_trans_transid_response;
	end
end
co__mulreq_trans_transid_sampled: cover property (|mulreq_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__mulreq_trans_transid_sample_no_overflow: assert property (mulreq_trans_transid_sampled != '1 || !mulreq_trans_transid_set);
end else begin
	am__mulreq_trans_transid_sample_no_overflow: assume property (mulreq_trans_transid_sampled != '1 || !mulreq_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__mulreq_trans_transid_hsk_or_drop: assert property (mulreq_val |-> s_eventually(!mulreq_val || mulreq_rdy));
// Assert that every request has a response and that every reponse has a request
as__mulreq_trans_transid_eventual_response: assert property (|mulreq_trans_transid_sampled |-> s_eventually(mulresp_val && (mulresp_transid == symb_mulreq_transid) ));
as__mulreq_trans_transid_was_a_request: assert property (mulreq_trans_transid_response |-> mulreq_trans_transid_set || mulreq_trans_transid_sampled);


// Modeling data integrity for mulreq_trans_transid
reg [2*WIDTH-1:0] mulreq_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		mulreq_trans_transid_data_model <= '0;
	end else if (mulreq_trans_transid_set) begin
		mulreq_trans_transid_data_model <= mulreq_data;
	end
end

as__mulreq_trans_transid_data_unique: assert property (|mulreq_trans_transid_sampled |-> !mulreq_trans_transid_set);
as__mulreq_trans_transid_data_integrity: assert property (|mulreq_trans_transid_sampled && mulreq_trans_transid_response |-> (mulresp_data == mulreq_trans_transid_data_model));

wire [WIDTH-1:0] unsigned_a = (mulreq_msg_a[WIDTH-1] ?  ~mulreq_msg_a + 1'b1 : mulreq_msg_a); 
wire [WIDTH-1:0] unsigned_b = (mulreq_msg_b[WIDTH-1] ?  ~mulreq_msg_b + 1'b1 : mulreq_msg_b);
wire [2*WIDTH-1:0] unsigned_res = {{WIDTH{1'b0}}, unsigned_a } * {{WIDTH{1'b0}}, unsigned_b };
wire [2*WIDTH-1:0] result = mulreq_msg_a[WIDTH-1] ^ mulreq_msg_b[WIDTH-1] ? ~unsigned_res + 1'b1 : unsigned_res; 
assign mulreq_transid = 1'b0;
assign mulreq_data = result;

assign mulresp_data = mulresp_msg_result;
assign mulresp_transid = 1'b0;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_mulreq_val: assert property(!$isunknown(mulreq_val));
	 as__no_x_mulreq_transid: assert property(mulreq_val |-> !$isunknown(mulreq_transid));
	 as__no_x_mulreq_data: assert property(mulreq_val |-> !$isunknown(mulreq_data));
	 as__no_x_mulresp_val: assert property(!$isunknown(mulresp_val));
	 as__no_x_mulresp_data: assert property(mulresp_val |-> !$isunknown(mulresp_data));
	 as__no_x_mulresp_transid: assert property(mulresp_val |-> !$isunknown(mulresp_transid));
`endif

//====DESIGNER-ADDED-SVA====//
endmodule