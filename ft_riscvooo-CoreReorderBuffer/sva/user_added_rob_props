reg [7:0] rob_alloc_req_transid_reg;
reg [7:0] rob_commit_transid_reg;

always @(posedge clk) begin
	if (reset) begin
		rob_alloc_req_transid_reg <= 8'b0;
		rob_commit_transid_reg <= 8'b0;
	end
	else begin
		if (rob_alloc_req_val && rob_alloc_req_rdy) begin
			rob_alloc_req_transid_reg <= rob_alloc_req_transid_reg + 1 ;
		end
		if (rob_commit_val) begin
			rob_commit_transid_reg <= rob_commit_transid_reg + 1;
		end
	end
end

// Assume that every slot that gets allocated eventually gets filled
integer i;
always @* begin
    for (i = 0; i < 16; i++) begin
        assume property (@(posedge clk) (rob_alloc_resp_slot == i) |-> s_eventually (rob_fill_slot == i));
    end
end

// Assert that one cycle after getting filled, a slot gets commited
// FIX: Only holds true for the head.
integer i;
always @* begin
    for (i = 0; i < 16; i++) begin
        assert property (@(posedge clk) ((rob_fill_slot == i && (rob_fill_val))) |-> s_eventually ((rob_commit_slot == i) && rob_commit_wen));
    end
end

// Assume fill slot is any of the pending slots
as_fill_slot_valid: assume property (@(posedge clk) rob_fill_val |-> (rob_fill_slot != 'bx) && (rob_fill_slot == pending_slots[0] ||
																			   									 pending_slots[1] ||
																			   									 pending_slots[2] ||
																			   									 pending_slots[3] ||
																			   									 pending_slots[4] ||
																			   									 pending_slots[5] ||
																			   									 pending_slots[6] ||
																			   									 pending_slots[7] ||
																			   									 pending_slots[8] ||
																			   									 pending_slots[9] ||
																			   									 pending_slots[10] ||
																			   									 pending_slots[11] ||
																			   									 pending_slots[12] ||
																			   									 pending_slots[13] ||
																			   									 pending_slots[14] ||
																			   									 pending_slots[15]));							


// Determine pending slots (have been allocated and not yet filled)
logic [3:0] pending_slots [15:0];
always @(posedge clk) begin
	if (reset) begin
		pending_slots <= '{default: 'x};
	end
	else begin
		if (rob_alloc_req_val && rob_alloc_req_rdy) begin
			pending_slots[rob_alloc_resp_slot] <= rob_alloc_resp_slot;
		end
		if (rob_commit_wen) begin
			pending_slots[rob_commit_slot] <= 4'bx;
		end
	end
end

// Assume that reset gets asserted for a clock cycle
// as_reset: assume property (@(posedge clk) s_eventually $rose(reset) |-> ##1 $fell(reset)); 

endmodule