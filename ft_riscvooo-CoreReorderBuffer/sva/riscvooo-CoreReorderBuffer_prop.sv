// This property file was autogenerated by AutoSVA on 2024-04-23
// to check the behavior of the original RTL module, whose interface is described below: 


module riscv_CoreReorderBuffer_prop
#(
		parameter ASSERT_INPUTS = 0)
(
		input         clk,
		input         reset,
		
		input         rob_alloc_req_val,
		input         rob_alloc_req_rdy, //output
		input  [ 4:0] rob_alloc_req_preg,
		
		input  [ 3:0] rob_alloc_resp_slot, //output
		
		input         rob_fill_val,
		input  [ 3:0] rob_fill_slot,
		
		input         rob_commit_wen, //output
		input  [ 3:0] rob_commit_slot, //output
		input  [ 4:0] rob_commit_rf_waddr //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (reset);

// Re-defined wires 
wire [4:0] rob_alloc_req_data;
wire rob_commit_val;
wire [3:0] rob_commit_data;
wire [3:0] rob_alloc_req_transid;
wire [3:0] rob_commit_transid;
wire [3:0] rob_fill_data;
wire [4:0] rob_alloc_commit_data; //renamed rob_commit_data to new name to capture that it is used for both the fill and alloc transaction
wire rob_commit_val;
wire [3:0] rob_fill_transid;
wire [3:0] rob_alloc_commit_transid; //renamed rob_commit_transid to new name to capture that it is used for both the fill and alloc transaction


// Symbolics and Handshake signals
wire [3:0] symb_rob_alloc_req_transid;
am__symb_rob_alloc_req_transid_stable: assume property($stable(symb_rob_alloc_req_transid));
wire rob_commit_hsk = rob_commit_val;
wire rob_alloc_req_hsk = rob_alloc_req_val && rob_alloc_req_rdy;
wire [3:0] symb_rob_fill_transid;
am__symb_rob_fill_transid_stable: assume property($stable(symb_rob_fill_transid));
wire rob_fill_hsk = rob_fill_val;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for rob_alloc_commit_trans
// Generate sampling signals and model
reg [3:0] rob_alloc_commit_trans_transid_sampled;
wire rob_alloc_commit_trans_transid_set = rob_alloc_req_hsk && rob_alloc_req_transid == symb_rob_alloc_req_transid;
wire rob_alloc_commit_trans_transid_response = rob_commit_hsk && rob_alloc_commit_transid == symb_rob_alloc_req_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		rob_alloc_commit_trans_transid_sampled <= '0;
	end else if (rob_alloc_commit_trans_transid_set || rob_alloc_commit_trans_transid_response ) begin
		rob_alloc_commit_trans_transid_sampled <= rob_alloc_commit_trans_transid_sampled + rob_alloc_commit_trans_transid_set - rob_alloc_commit_trans_transid_response;
	end
end
co__rob_alloc_commit_trans_transid_sampled: cover property (|rob_alloc_commit_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__rob_alloc_commit_trans_transid_sample_no_overflow: assert property (rob_alloc_commit_trans_transid_sampled != '1 || !rob_alloc_commit_trans_transid_set);
end else begin
	am__rob_alloc_commit_trans_transid_sample_no_overflow: assume property (rob_alloc_commit_trans_transid_sampled != '1 || !rob_alloc_commit_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__rob_alloc_commit_trans_transid_hsk_or_drop: assert property (rob_alloc_req_val |-> s_eventually(!rob_alloc_req_val || rob_alloc_req_rdy));
// Assert that every request has a response and that every reponse has a request
as__rob_alloc_commit_trans_transid_eventual_response: assert property (|rob_alloc_commit_trans_transid_sampled |-> s_eventually(rob_commit_val && (rob_alloc_commit_transid == symb_rob_alloc_req_transid) ));
as__rob_alloc_commit_trans_transid_was_a_request: assert property (rob_alloc_commit_trans_transid_response |-> rob_alloc_commit_trans_transid_set || rob_alloc_commit_trans_transid_sampled);


// Modeling data integrity for rob_alloc_commit_trans_transid
reg [4:0] rob_alloc_commit_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		rob_alloc_commit_trans_transid_data_model <= '0;
	end else if (rob_alloc_commit_trans_transid_set) begin
		rob_alloc_commit_trans_transid_data_model <= rob_alloc_req_data;
	end
end

as__rob_alloc_commit_trans_transid_data_unique: assert property (|rob_alloc_commit_trans_transid_sampled |-> !rob_alloc_commit_trans_transid_set);
as__rob_alloc_commit_trans_transid_data_integrity: assert property (|rob_alloc_commit_trans_transid_sampled && rob_alloc_commit_trans_transid_response |-> (rob_alloc_commit_data == rob_alloc_commit_trans_transid_data_model));

// Modeling incoming request for rob_fill_commit_trans
// Generate sampling signals and model
reg [3:0] rob_fill_commit_trans_transid_sampled;
wire rob_fill_commit_trans_transid_set = rob_fill_hsk && rob_fill_transid == symb_rob_fill_transid;
wire rob_fill_commit_trans_transid_response = rob_commit_hsk && rob_commit_transid == symb_rob_fill_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		rob_fill_commit_trans_transid_sampled <= '0;
	end else if (rob_fill_commit_trans_transid_set || rob_fill_commit_trans_transid_response ) begin
		rob_fill_commit_trans_transid_sampled <= rob_fill_commit_trans_transid_sampled + rob_fill_commit_trans_transid_set - rob_fill_commit_trans_transid_response;
	end
end
co__rob_fill_commit_trans_transid_sampled: cover property (|rob_fill_commit_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__rob_fill_commit_trans_transid_sample_no_overflow: assert property (rob_fill_commit_trans_transid_sampled != '1 || !rob_fill_commit_trans_transid_set);
end else begin
	am__rob_fill_commit_trans_transid_sample_no_overflow: assume property (rob_fill_commit_trans_transid_sampled != '1 || !rob_fill_commit_trans_transid_set);
end


// Assert that every request has a response and that every reponse has a request
as__rob_fill_commit_trans_transid_eventual_response: assert property (|rob_fill_commit_trans_transid_sampled |-> s_eventually(rob_commit_val && (rob_commit_transid == symb_rob_fill_transid) ));
as__rob_fill_commit_trans_transid_was_a_request: assert property (rob_fill_commit_trans_transid_response |-> rob_fill_commit_trans_transid_set || rob_fill_commit_trans_transid_sampled);


// Modeling data integrity for rob_fill_commit_trans_transid
reg [3:0] rob_fill_commit_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		rob_fill_commit_trans_transid_data_model <= '0;
	end else if (rob_fill_commit_trans_transid_set) begin
		rob_fill_commit_trans_transid_data_model <= rob_fill_data;
	end
end

as__rob_fill_commit_trans_transid_data_unique: assert property (|rob_fill_commit_trans_transid_sampled |-> !rob_fill_commit_trans_transid_set);
as__rob_fill_commit_trans_transid_data_integrity: assert property (|rob_fill_commit_trans_transid_sampled && rob_fill_commit_trans_transid_response |-> (rob_commit_data == rob_fill_commit_trans_transid_data_model));

assign rob_commit_val = rob_commit_wen;
assign rob_alloc_req_transid = rob_alloc_req_transid_reg;
assign rob_commit_transid = rob_commit_slot;
assign rob_alloc_commit_transid = rob_commit_transid_reg; 
assign rob_alloc_req_data = rob_alloc_req_preg;
assign rob_fill_transid = rob_fill_slot;
assign rob_fill_data = rob_fill_slot;
assign rob_commit_data = rob_commit_slot;
assign rob_alloc_commit_data = rob_commit_rf_waddr;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_rob_commit_val: assert property(!$isunknown(rob_commit_val));
	 as__no_x_rob_commit_transid: assert property(rob_commit_val |-> !$isunknown(rob_commit_transid));
	 as__no_x_rob_commit_data: assert property(rob_commit_val |-> !$isunknown(rob_commit_data));
	 as__no_x_rob_alloc_req_val: assert property(!$isunknown(rob_alloc_req_val));
	 as__no_x_rob_alloc_req_transid: assert property(rob_alloc_req_val |-> !$isunknown(rob_alloc_req_transid));
	 as__no_x_rob_alloc_req_data: assert property(rob_alloc_req_val |-> !$isunknown(rob_alloc_req_data));
	 as__no_x_rob_fill_val: assert property(!$isunknown(rob_fill_val));
	 as__no_x_rob_fill_transid: assert property(rob_fill_val |-> !$isunknown(rob_fill_transid));
	 as__no_x_rob_fill_data: assert property(rob_fill_val |-> !$isunknown(rob_fill_data));
`endif

//====DESIGNER-ADDED-SVA====//
reg [7:0] rob_alloc_req_transid_reg;
reg [7:0] rob_commit_transid_reg;
reg [3:0] head; 
reg [3:0] tail; 

wire [3:0] num_entries = (tail < head) ? (5'd17 - head + tail) : (tail - head); 

//maximum number of entries is 16
wire full = (num_entries > 16);
always @(posedge clk) begin
	if (reset) begin
		rob_alloc_req_transid_reg <= 8'b0;
		rob_commit_transid_reg <= 8'b0;
		head <= 4'b0; 
		tail <= 4'b0;
	end
	else begin
		if (rob_alloc_req_val && rob_alloc_req_rdy) begin
			rob_alloc_req_transid_reg <= rob_alloc_req_transid_reg + 1 ;
			tail <= tail + 4'b1; 
		end
		if (rob_commit_val) begin
			rob_commit_transid_reg <= rob_commit_transid_reg + 1;
			head <= head + 4'b1; 
		end
	end
end

// Assume that every slot that gets allocated eventually gets filled
integer i;
always @* begin
    for (i = 0; i < 16; i++) begin
        as_alloc_fill: assume property (@(posedge clk) (rob_alloc_resp_slot == i) |-> s_eventually (rob_fill_slot == i));
    end
end

// Assume fill slot is any of the pending slots
wire [4:0] test = rob_fill_slot + 5'b1;
as_fill_slot_valid: assume property (@(posedge clk) rob_fill_val |-> (((rob_fill_slot + 5'b1) == pending_slots[0]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[1]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[2]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[3]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[4]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[5]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[6]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[7]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[8]) || 
																	  ((rob_fill_slot + 5'b1) == pending_slots[9]) || 
																	  ((rob_fill_slot + 5'b1) == pending_slots[10]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[11]) ||
																	  ((rob_fill_slot + 5'b1) == pending_slots[12]) || 
																	  ((rob_fill_slot + 5'b1) == pending_slots[13]) || 
																	  ((rob_fill_slot + 5'b1) == pending_slots[14]) || 
																	  ((rob_fill_slot + 5'b1) == pending_slots[15]))) ;
																			   									
						


// Determine pending slots (have been allocated and not yet filled)
logic [4:0] pending_slots [15:0];
always @(posedge clk) begin
	if (reset) begin
		pending_slots <= '{default: '0};
	end
	else begin
		if (rob_alloc_req_val && rob_alloc_req_rdy) begin
			pending_slots[rob_alloc_resp_slot] <= rob_alloc_resp_slot + 5'b1;
		end
		if (rob_fill_val) begin
			pending_slots[rob_fill_slot] <= 5'b0;
		end
	end
end

// Assume that fill_val only gets asserted if pending_slots is non-empty
as_fill_val: assume property ((pending_slots != '{default: '0}) |-> (rob_fill_val == 1'b1));

// assert that the rob_alloc_req_rdy only when not full
as_alloc_rdy_not_full: assert property ((full == 1'b0) |-> rob_alloc_req_rdy); 

// assert that rob_alloc_resp_slot is inserted after the tail
as_alloc_resp_slot_equal_tail: assert property ((rob_alloc_req_val && rob_alloc_req_rdy) |-> (rob_alloc_resp_slot == tail));

//Assert that one cycle after getting filled the head gets commited
// FIX: Only holds true for the head.
as_head_commits_after_fill: assert property (((rob_fill_slot == head) && rob_fill_val) |-> ##1 ((rob_commit_slot == head) && rob_commit_wen));

endmodule