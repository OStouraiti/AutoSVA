// This property file was autogenerated by AutoSVA on 2024-05-07
// to check the behavior of the original RTL module, whose interface is described below: 


`include "../../ece475-lab1/imuldiv-DivReqMsg.v"

module imuldiv_IntDivIterative_prop
#(
		parameter ASSERT_INPUTS = 0, parameter WIDTH = 32)
(
		
		input         clk,
		input         reset,
		
		input         divreq_msg_fn,
		input  [WIDTH-1:0] divreq_msg_a,
		input  [WIDTH-1:0] divreq_msg_b,
		input         divreq_val,
		input         divreq_rdy, //output
		
		input  [2*WIDTH-1:0] divresp_msg_result, //output
		input         divresp_val, //output
		input         divresp_rdy
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (reset);

// Re-defined wires 
wire [2*WIDTH-1:0] divreq_data;
wire divreq_transid;
wire [2*WIDTH-1:0] divresp_data;
wire divresp_transid;

// Symbolics and Handshake signals
wire [0:0] symb_divreq_transid;
am__symb_divreq_transid_stable: assume property($stable(symb_divreq_transid));
wire divresp_hsk = divresp_val && divresp_rdy;
wire divreq_hsk = divreq_val && divreq_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for divreq_trans
if (ASSERT_INPUTS) begin
	as__divreq_trans_fairness: assert property (divresp_val |-> s_eventually(divresp_rdy));
end else begin
	am__divreq_trans_fairness: assume property (divresp_val |-> s_eventually(divresp_rdy));
end

// Generate sampling signals and model
reg [3:0] divreq_trans_transid_sampled;
wire divreq_trans_transid_set = divreq_hsk && divreq_transid == symb_divreq_transid;
wire divreq_trans_transid_response = divresp_hsk && divresp_transid == symb_divreq_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		divreq_trans_transid_sampled <= '0;
	end else if (divreq_trans_transid_set || divreq_trans_transid_response ) begin
		divreq_trans_transid_sampled <= divreq_trans_transid_sampled + divreq_trans_transid_set - divreq_trans_transid_response;
	end
end
co__divreq_trans_transid_sampled: cover property (|divreq_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__divreq_trans_transid_sample_no_overflow: assert property (divreq_trans_transid_sampled != '1 || !divreq_trans_transid_set);
end else begin
	am__divreq_trans_transid_sample_no_overflow: assume property (divreq_trans_transid_sampled != '1 || !divreq_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__divreq_trans_transid_hsk_or_drop: assert property (divreq_val |-> s_eventually(!divreq_val || divreq_rdy));
// Assert that every request has a response and that every reponse has a request
as__divreq_trans_transid_eventual_response: assert property (|divreq_trans_transid_sampled |-> s_eventually(divresp_val && (divresp_transid == symb_divreq_transid) ));
as__divreq_trans_transid_was_a_request: assert property (divreq_trans_transid_response |-> divreq_trans_transid_set || divreq_trans_transid_sampled);


// Modeling data integrity for divreq_trans_transid
reg [2*WIDTH-1:0] divreq_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		divreq_trans_transid_data_model <= '0;
	end else if (divreq_trans_transid_set) begin
		divreq_trans_transid_data_model <= divreq_data;
	end
end

as__divreq_trans_transid_data_unique: assert property (|divreq_trans_transid_sampled |-> !divreq_trans_transid_set);
as__divreq_trans_transid_data_integrity: assert property (|divreq_trans_transid_sampled && divreq_trans_transid_response |-> (divresp_data == divreq_trans_transid_data_model));

assign divresp_data = divresp_msg_result;
assign divresp_transid = 1'b0;
assign divreq_data = result;
assign divreq_transid = 1'b0;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_divresp_val: assert property(!$isunknown(divresp_val));
	 as__no_x_divresp_data: assert property(divresp_val |-> !$isunknown(divresp_data));
	 as__no_x_divresp_transid: assert property(divresp_val |-> !$isunknown(divresp_transid));
	 as__no_x_divreq_val: assert property(!$isunknown(divreq_val));
	 as__no_x_divreq_data: assert property(divreq_val |-> !$isunknown(divreq_data));
	 as__no_x_divreq_transid: assert property(divreq_val |-> !$isunknown(divreq_transid));
`endif

//====DESIGNER-ADDED-SVA====//
wire is_op_signed      = ( divreq_msg_fn == `IMULDIV_DIVREQ_MSG_FUNC_SIGNED );
wire [WIDTH-1:0] unsigned_a = ( divreq_msg_a[WIDTH-1]) ? ~divreq_msg_a + 1'b1 : divreq_msg_a;
wire [WIDTH-1:0] unsigned_b = (divreq_msg_b[WIDTH-1]) ? ~divreq_msg_b + 1'b1 : divreq_msg_b; 

wire [WIDTH-1:0] remu_result = divreq_msg_a % divreq_msg_b; 
wire [WIDTH-1:0] divu_result = divreq_msg_a / divreq_msg_b;
wire [WIDTH-1:0] rem_result = divreq_msg_a[WIDTH-1] ? ~(unsigned_a % unsigned_b) + 1'b1 : (unsigned_a % unsigned_b); 
wire [WIDTH-1:0] div_result = (divreq_msg_a[WIDTH-1] ^ divreq_msg_b[WIDTH-1]) ? ~(unsigned_a / unsigned_b) + 1'b1 :
																   unsigned_a / unsigned_b;
wire [2*WIDTH-1:0] result = (is_op_signed) ? {rem_result, div_result }:
									{remu_result, divu_result };
endmodule