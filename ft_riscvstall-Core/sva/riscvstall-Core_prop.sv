// This property file was autogenerated by AutoSVA on 2024-05-03
// to check the behavior of the original RTL module, whose interface is described below: 


`include "../../ece475-lab2/vc/vc-MemReqMsg.v"
`include "../../ece475-lab2/vc/vc-MemRespMsg.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreCtrl.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreDpath.v"
`include "../../ece475-lab2/riscvstall/riscvstall-InstMsg.v"
`include "../../ece475-lab2/riscvstall/riscvstall-Instructions.v"


module riscv_Core_prop
#(
		parameter ASSERT_INPUTS = 0)
(
		
		input         clk,
		input         reset,
		
		// Instruction Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] imemreq_msg, //output
		input                                  imemreq_val, //output
		input                                  imemreq_rdy,
		
		// Instruction Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] imemresp_msg,
		input                               imemresp_val,
		
		// Data Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] dmemreq_msg, //output
		input                                  dmemreq_val, //output
		input                                  dmemreq_rdy,
		
		// Data Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] dmemresp_msg,
		input                               dmemresp_val,
		
		// CSR Status Register Output to Host
		
		input  [31:0] csr_status //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (reset);

// Re-defined wires 
wire [7:0] ir_transid;
wire [7:0] rf_transid;
wire rf_val;
wire rf_rdy;
wire ir_val;
wire ir_rdy;
wire [31:0] ir_data;
wire [31:0] rf_data;
wire [7:0] load_ir_transid;
wire [7:0] load_dmem_transid;
wire load_ir_rdy;
wire load_ir_val;
wire load_dmem_rdy;
wire load_dmem_val;
wire [31:0] load_ir_data;
wire [31:0] load_dmem_data;
wire [7:0] load_dmem_out_transid;
wire [7:0] load_rf_transid;
wire load_dmem_out_rdy;
wire load_dmem_out_val;
wire load_rf_rdy;
wire load_rf_val;
wire [31:0] load_dmem_out_data;
wire [31:0] load_rf_data;
wire [7:0] store_ir_transid;
wire [7:0] store_dmem_transid;
wire store_ir_rdy;
wire store_ir_val;
wire store_dmem_rdy;
wire store_dmem_val;
wire [31:0] store_ir_data;
wire [31:0] store_dmem_data;

// Symbolics and Handshake signals
wire [7:0] symb_load_dmem_out_transid;
am__symb_load_dmem_out_transid_stable: assume property($stable(symb_load_dmem_out_transid));
wire load_rf_hsk = load_rf_val && load_rf_rdy;
wire load_dmem_out_hsk = load_dmem_out_val && load_dmem_out_rdy;
wire [7:0] symb_ir_transid;
am__symb_ir_transid_stable: assume property($stable(symb_ir_transid));
wire rf_hsk = rf_val && rf_rdy;
wire ir_hsk = ir_val && ir_rdy;
wire [7:0] symb_store_ir_transid;
am__symb_store_ir_transid_stable: assume property($stable(symb_store_ir_transid));
wire store_dmem_hsk = store_dmem_val && store_dmem_rdy;
wire store_ir_hsk = store_ir_val && store_ir_rdy;
wire [7:0] symb_load_ir_transid;
am__symb_load_ir_transid_stable: assume property($stable(symb_load_ir_transid));
wire load_dmem_hsk = load_dmem_val && load_dmem_rdy;
wire load_ir_hsk = load_ir_val && load_ir_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for load_dmem_rf_trans
if (ASSERT_INPUTS) begin
	as__load_dmem_rf_trans_fairness: assert property (load_rf_val |-> s_eventually(load_rf_rdy));
end else begin
	am__load_dmem_rf_trans_fairness: assume property (load_rf_val |-> s_eventually(load_rf_rdy));
end

// Generate sampling signals and model
reg [3:0] load_dmem_rf_trans_transid_sampled;
wire load_dmem_rf_trans_transid_set = load_dmem_out_hsk && load_dmem_out_transid == symb_load_dmem_out_transid;
wire load_dmem_rf_trans_transid_response = load_rf_hsk && load_rf_transid == symb_load_dmem_out_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		load_dmem_rf_trans_transid_sampled <= '0;
	end else if (load_dmem_rf_trans_transid_set || load_dmem_rf_trans_transid_response ) begin
		load_dmem_rf_trans_transid_sampled <= load_dmem_rf_trans_transid_sampled + load_dmem_rf_trans_transid_set - load_dmem_rf_trans_transid_response;
	end
end
co__load_dmem_rf_trans_transid_sampled: cover property (|load_dmem_rf_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__load_dmem_rf_trans_transid_sample_no_overflow: assert property (load_dmem_rf_trans_transid_sampled != '1 || !load_dmem_rf_trans_transid_set);
end else begin
	am__load_dmem_rf_trans_transid_sample_no_overflow: assume property (load_dmem_rf_trans_transid_sampled != '1 || !load_dmem_rf_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__load_dmem_rf_trans_transid_hsk_or_drop: assert property (load_dmem_out_val |-> s_eventually(!load_dmem_out_val || load_dmem_out_rdy));
// Assert that every request has a response and that every reponse has a request
as__load_dmem_rf_trans_transid_eventual_response: assert property (|load_dmem_rf_trans_transid_sampled |-> s_eventually(load_rf_val && (load_rf_transid == symb_load_dmem_out_transid) ));
as__load_dmem_rf_trans_transid_was_a_request: assert property (load_dmem_rf_trans_transid_response |-> load_dmem_rf_trans_transid_set || load_dmem_rf_trans_transid_sampled);


// Modeling data integrity for load_dmem_rf_trans_transid
reg [31:0] load_dmem_rf_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		load_dmem_rf_trans_transid_data_model <= '0;
	end else if (load_dmem_rf_trans_transid_set) begin
		load_dmem_rf_trans_transid_data_model <= load_dmem_out_data;
	end
end

as__load_dmem_rf_trans_transid_data_unique: assert property (|load_dmem_rf_trans_transid_sampled |-> !load_dmem_rf_trans_transid_set);
as__load_dmem_rf_trans_transid_data_integrity: assert property (|load_dmem_rf_trans_transid_sampled && load_dmem_rf_trans_transid_response |-> (load_rf_data == load_dmem_rf_trans_transid_data_model));

// Modeling incoming request for ir_rf_trans
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_fairness: assert property (rf_val |-> s_eventually(rf_rdy));
end else begin
	am__ir_rf_trans_fairness: assume property (rf_val |-> s_eventually(rf_rdy));
end

// Generate sampling signals and model
reg [3:0] ir_rf_trans_transid_sampled;
wire ir_rf_trans_transid_set = ir_hsk && ir_transid == symb_ir_transid;
wire ir_rf_trans_transid_response = rf_hsk && rf_transid == symb_ir_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_sampled <= '0;
	end else if (ir_rf_trans_transid_set || ir_rf_trans_transid_response ) begin
		ir_rf_trans_transid_sampled <= ir_rf_trans_transid_sampled + ir_rf_trans_transid_set - ir_rf_trans_transid_response;
	end
end
co__ir_rf_trans_transid_sampled: cover property (|ir_rf_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_transid_sample_no_overflow: assert property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end else begin
	am__ir_rf_trans_transid_sample_no_overflow: assume property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__ir_rf_trans_transid_hsk_or_drop: assert property (ir_val |-> s_eventually(!ir_val || ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__ir_rf_trans_transid_eventual_response: assert property (|ir_rf_trans_transid_sampled |-> s_eventually(rf_val && (rf_transid == symb_ir_transid) ));
as__ir_rf_trans_transid_was_a_request: assert property (ir_rf_trans_transid_response |-> ir_rf_trans_transid_set || ir_rf_trans_transid_sampled);


// Modeling data integrity for ir_rf_trans_transid
reg [31:0] ir_rf_trans_transid_data_model;
reg [31:0] ir_rf_trans_transid_data_model_rd;

always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_data_model <= '0;
		ir_rf_trans_transid_data_model_rd <= '0;
	end else if (ir_rf_trans_transid_set) begin
		ir_rf_trans_transid_data_model <= ir_data;
		ir_rf_trans_transid_data_model_rd <= rd_reg;
	end
end

as__ir_rf_trans_transid_data_unique: assert property (|ir_rf_trans_transid_sampled |-> !ir_rf_trans_transid_set);
as__ir_rf_trans_transid_data_integrity: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response |-> (rf_data == ir_rf_trans_transid_data_model));

// Modeling incoming request for store_ir_dmem_trans
if (ASSERT_INPUTS) begin
	as__store_ir_dmem_trans_fairness: assert property (store_dmem_val |-> s_eventually(store_dmem_rdy));
end else begin
	am__store_ir_dmem_trans_fairness: assume property (store_dmem_val |-> s_eventually(store_dmem_rdy));
end

// Generate sampling signals and model
reg [3:0] store_ir_dmem_trans_transid_sampled;
wire store_ir_dmem_trans_transid_set = store_ir_hsk && store_ir_transid == symb_store_ir_transid;
wire store_ir_dmem_trans_transid_response = store_dmem_hsk && store_dmem_transid == symb_store_ir_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		store_ir_dmem_trans_transid_sampled <= '0;
	end else if (store_ir_dmem_trans_transid_set || store_ir_dmem_trans_transid_response ) begin
		store_ir_dmem_trans_transid_sampled <= store_ir_dmem_trans_transid_sampled + store_ir_dmem_trans_transid_set - store_ir_dmem_trans_transid_response;
	end
end
co__store_ir_dmem_trans_transid_sampled: cover property (|store_ir_dmem_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__store_ir_dmem_trans_transid_sample_no_overflow: assert property (store_ir_dmem_trans_transid_sampled != '1 || !store_ir_dmem_trans_transid_set);
end else begin
	am__store_ir_dmem_trans_transid_sample_no_overflow: assume property (store_ir_dmem_trans_transid_sampled != '1 || !store_ir_dmem_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__store_ir_dmem_trans_transid_hsk_or_drop: assert property (store_ir_val |-> s_eventually(!store_ir_val || store_ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__store_ir_dmem_trans_transid_eventual_response: assert property (|store_ir_dmem_trans_transid_sampled |-> s_eventually(store_dmem_val && (store_dmem_transid == symb_store_ir_transid) ));
as__store_ir_dmem_trans_transid_was_a_request: assert property (store_ir_dmem_trans_transid_response |-> store_ir_dmem_trans_transid_set || store_ir_dmem_trans_transid_sampled);


// Modeling data integrity for store_ir_dmem_trans_transid
reg [31:0] store_ir_dmem_trans_transid_data_model;
reg [31:0] store_ir_dmem_trans_transid_data_model_rs2;
always_ff @(posedge clk) begin
	if(reset) begin
		store_ir_dmem_trans_transid_data_model <= '0;
		store_ir_dmem_trans_transid_data_model_rs2 <= '0;
	end else if (store_ir_dmem_trans_transid_set) begin
		store_ir_dmem_trans_transid_data_model <= store_ir_data;
		store_ir_dmem_trans_transid_data_model_rs2 <= rs2_data_reg;
	end
end

as__store_ir_dmem_trans_transid_data_unique: assert property (|store_ir_dmem_trans_transid_sampled |-> !store_ir_dmem_trans_transid_set);
as__store_ir_dmem_trans_transid_data_integrity: assert property (|store_ir_dmem_trans_transid_sampled && store_ir_dmem_trans_transid_response |-> (store_dmem_data == store_ir_dmem_trans_transid_data_model));

// Modeling incoming request for load_ir_dmem_trans
if (ASSERT_INPUTS) begin
	as__load_ir_dmem_trans_fairness: assert property (load_dmem_val |-> s_eventually(load_dmem_rdy));
end else begin
	am__load_ir_dmem_trans_fairness: assume property (load_dmem_val |-> s_eventually(load_dmem_rdy));
end

// Generate sampling signals and model
reg [3:0] load_ir_dmem_trans_transid_sampled;
wire load_ir_dmem_trans_transid_set = load_ir_hsk && load_ir_transid == symb_load_ir_transid;
wire load_ir_dmem_trans_transid_response = load_dmem_hsk && load_dmem_transid == symb_load_ir_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		load_ir_dmem_trans_transid_sampled <= '0;
	end else if (load_ir_dmem_trans_transid_set || load_ir_dmem_trans_transid_response ) begin
		load_ir_dmem_trans_transid_sampled <= load_ir_dmem_trans_transid_sampled + load_ir_dmem_trans_transid_set - load_ir_dmem_trans_transid_response;
	end
end
co__load_ir_dmem_trans_transid_sampled: cover property (|load_ir_dmem_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__load_ir_dmem_trans_transid_sample_no_overflow: assert property (load_ir_dmem_trans_transid_sampled != '1 || !load_ir_dmem_trans_transid_set);
end else begin
	am__load_ir_dmem_trans_transid_sample_no_overflow: assume property (load_ir_dmem_trans_transid_sampled != '1 || !load_ir_dmem_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__load_ir_dmem_trans_transid_hsk_or_drop: assert property (load_ir_val |-> s_eventually(!load_ir_val || load_ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__load_ir_dmem_trans_transid_eventual_response: assert property (|load_ir_dmem_trans_transid_sampled |-> s_eventually(load_dmem_val && (load_dmem_transid == symb_load_ir_transid) ));
as__load_ir_dmem_trans_transid_was_a_request: assert property (load_ir_dmem_trans_transid_response |-> load_ir_dmem_trans_transid_set || load_ir_dmem_trans_transid_sampled);


// Modeling data integrity for load_ir_dmem_trans_transid
reg [31:0] load_ir_dmem_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		load_ir_dmem_trans_transid_data_model <= '0;
	end else if (load_ir_dmem_trans_transid_set) begin
		load_ir_dmem_trans_transid_data_model <= load_ir_data;
	end
end

as__load_ir_dmem_trans_transid_data_unique: assert property (|load_ir_dmem_trans_transid_sampled |-> !load_ir_dmem_trans_transid_set);
as__load_ir_dmem_trans_transid_data_integrity: assert property (|load_ir_dmem_trans_transid_sampled && load_ir_dmem_trans_transid_response |-> (load_dmem_data == load_ir_dmem_trans_transid_data_model));

assign store_ir_transid = store_ir_transid_reg;
assign ir_val = ctrl.inst_val_Dhl && (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl);
assign load_dmem_transid = load_dmem_transid_reg;
assign rf_rdy = 1'b1;
assign ir_data = alu_output_reg;
assign load_ir_rdy = !stall_Dhl_reg;
assign load_rf_transid = load_rf_transid_reg;
assign ir_transid = ir_transid_reg;
assign ir_rdy = !stall_Dhl_reg;
assign load_rf_data = load_rf_data_reg;
assign rf_data = rf_data_reg;
assign store_dmem_transid = store_dmem_transid_reg;
assign rf_transid = rf_transid_reg;
assign load_dmem_rdy = dmemreq_rdy_Mhl;
assign store_dmem_rdy = dmemreq_rdy_Mhl;
assign load_ir_data = load_mem_addr_reg;
assign load_dmem_out_data = load_dmem_out_data_reg;
assign store_ir_val = ctrl.inst_val_Dhl && type_store_instr_Dhl;
assign load_dmem_out_val = ctrl.inst_val_Mhl && type_load_instr_Mhl && dmemreq_val_Mhl && !stall_Mhl_reg;
assign store_dmem_data = store_dmemreq_msg_addr_Whl;
assign load_rf_rdy = 1'b1;
assign store_ir_data = store_mem_addr_reg;
assign load_dmem_out_transid = load_dmem_out_transid_reg;
assign load_ir_val = ctrl.inst_val_Dhl && type_load_instr_Dhl;
assign load_ir_transid = load_ir_transid_reg;
assign load_dmem_out_rdy = dmemresp_val;
assign store_dmem_val = ctrl.inst_val_Mhl && ((dmemreq_msg_rw_Mhl == 2'd2) && dmemreq_val_Mhl) && type_store_instr_Mhl && !stall_Mhl_reg;
assign load_dmem_data = load_dmemreq_msg_addr_Whl;
assign load_rf_val = dpath.rf_wen_Whl && ctrl.inst_val_Whl && type_load_instr_Whl;
assign store_ir_rdy = !stall_Dhl_reg;
assign rf_val = ctrl.inst_val_Whl && ctrl.rf_wen_Whl && (type_alu_r_instr_Whl || type_alu_i_instr_Whl);
assign load_dmem_val = ctrl.inst_val_Mhl && (dmemreq_msg_rw_Mhl && dmemreq_val_Mhl) && type_load_instr_Mhl && !stall_Mhl_reg;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_load_rf_val: assert property(!$isunknown(load_rf_val));
	 as__no_x_load_rf_transid: assert property(load_rf_val |-> !$isunknown(load_rf_transid));
	 as__no_x_load_rf_data: assert property(load_rf_val |-> !$isunknown(load_rf_data));
	 as__no_x_load_ir_val: assert property(!$isunknown(load_ir_val));
	 as__no_x_load_ir_transid: assert property(load_ir_val |-> !$isunknown(load_ir_transid));
	 as__no_x_load_ir_data: assert property(load_ir_val |-> !$isunknown(load_ir_data));
	 as__no_x_ir_val: assert property(!$isunknown(ir_val));
	 as__no_x_ir_data: assert property(ir_val |-> !$isunknown(ir_data));
	 as__no_x_ir_transid: assert property(ir_val |-> !$isunknown(ir_transid));
	 as__no_x_rf_val: assert property(!$isunknown(rf_val));
	 as__no_x_rf_data: assert property(rf_val |-> !$isunknown(rf_data));
	 as__no_x_rf_transid: assert property(rf_val |-> !$isunknown(rf_transid));
	 as__no_x_store_ir_val: assert property(!$isunknown(store_ir_val));
	 as__no_x_store_ir_data: assert property(store_ir_val |-> !$isunknown(store_ir_data));
	 as__no_x_store_ir_transid: assert property(store_ir_val |-> !$isunknown(store_ir_transid));
	 as__no_x_load_dmem_out_val: assert property(!$isunknown(load_dmem_out_val));
	 as__no_x_load_dmem_out_transid: assert property(load_dmem_out_val |-> !$isunknown(load_dmem_out_transid));
	 as__no_x_load_dmem_out_data: assert property(load_dmem_out_val |-> !$isunknown(load_dmem_out_data));
	 as__no_x_store_dmem_val: assert property(!$isunknown(store_dmem_val));
	 as__no_x_store_dmem_transid: assert property(store_dmem_val |-> !$isunknown(store_dmem_transid));
	 as__no_x_store_dmem_data: assert property(store_dmem_val |-> !$isunknown(store_dmem_data));
	 as__no_x_load_dmem_val: assert property(!$isunknown(load_dmem_val));
	 as__no_x_load_dmem_data: assert property(load_dmem_val |-> !$isunknown(load_dmem_data));
	 as__no_x_load_dmem_transid: assert property(load_dmem_val |-> !$isunknown(load_dmem_transid));
`endif

//====DESIGNER-ADDED-SVA====//
// Type of instruction wires
// ALU R-type
wire type_add_instr_Dhl;
wire type_sub_instr_Dhl;
wire type_sll_instr_Dhl;
wire type_slt_instr_Dhl;
wire type_sltu_instr_Dhl;
wire type_xor_instr_Dhl;
wire type_srl_instr_Dhl;
wire type_sra_instr_Dhl;
wire type_or_instr_Dhl;
wire type_and_instr_Dhl;

wire type_add_instr_Whl;
wire type_sub_instr_Whl;
wire type_sll_instr_Whl;
wire type_slt_instr_Whl;
wire type_sltu_instr_Whl;
wire type_xor_instr_Whl;
wire type_srl_instr_Whl;
wire type_sra_instr_Whl;
wire type_or_instr_Whl;
wire type_and_instr_Whl;

// ALU I-type
wire type_addi_instr_Dhl;
wire type_slti_instr_Dhl;
wire type_sltiu_instr_Dhl;
wire type_xori_instr_Dhl;
wire type_ori_instr_Dhl;
wire type_andi_instr_Dhl;
wire type_slli_instr_Dhl;
wire type_srli_instr_Dhl;
wire type_srai_instr_Dhl;

wire type_addi_instr_Whl;
wire type_slti_instr_Whl;
wire type_sltiu_instr_Whl;
wire type_xori_instr_Whl;
wire type_ori_instr_Whl;
wire type_andi_instr_Whl;
wire type_slli_instr_Whl;
wire type_srli_instr_Whl;
wire type_srai_instr_Whl;

// Load
wire type_lw_instr_Dhl;
wire type_lb_instr_Dhl;
wire type_lh_instr_Dhl;
wire type_lbu_instr_Dhl;
wire type_lhu_instr_Dhl;

wire type_lw_instr_Mhl;
wire type_lb_instr_Mhl;
wire type_lh_instr_Mhl;
wire type_lbu_instr_Mhl;
wire type_lhu_instr_Mhl;

wire type_lw_instr_Whl;
wire type_lb_instr_Whl;
wire type_lh_instr_Whl;
wire type_lbu_instr_Whl;
wire type_lhu_instr_Whl;

wire type_load_instr_Dhl;
wire type_load_instr_Mhl;
wire type_load_instr_Whl;

// Store
wire type_sw_instr_Dhl;
wire type_sb_instr_Dhl;
wire type_sh_instr_Dhl;

wire type_sw_instr_Mhl;
wire type_sb_instr_Mhl;
wire type_sh_instr_Mhl;

wire type_sw_instr_Whl;
wire type_sb_instr_Whl;
wire type_sh_instr_Whl;

wire type_store_instr_Dhl;
wire type_store_instr_Mhl;
wire type_store_instr_Whl;

// Register definitons
reg [7:0] ir_transid_reg;
reg [7:0] rf_transid_reg; 
reg [31:0] rf_data_reg;
reg stall_Dhl_reg;
reg stall_Mhl_reg; 
reg [4:0] rd_reg;
reg [4:0] rf_waddr_Whl_reg;
reg [31:0] alu_output; 
reg [31:0] alu_output_reg;
reg [31:0] ir_Dhl_prev;
reg [31:0] ir_Xhl;
reg [31:0] ir_Mhl;
reg [31:0] ir_Whl;

// Unsigned wires for muldiv
reg [31:0] unsigned_a;
reg [31:0] unsigned_b;
reg [31:0] unsigned_res;

// Load Regs 
reg [1:0] dmemreq_msg_rw_Mhl;
reg [1:0] dmemreq_msg_rw_Xhl;
reg [31:0] load_mem_addr_reg;
reg [7:0] load_ir_transid_reg;
reg [7:0] load_dmem_transid_reg; 
reg [31:0] load_mem_addr; 
reg dmemreq_val_Mhl;
reg dmemreq_rdy_Mhl;
reg [31:0] load_dmemreq_msg_addr_Mhl;
reg [31:0] load_dmemreq_msg_addr_Whl; 
reg [31:0] store_dmemreq_msg_addr_Mhl;
reg [31:0] store_dmemreq_msg_addr_Whl;
reg [7:0] load_rf_transid_reg;
reg [7:0] load_dmem_out_transid_reg;
reg [31:0] load_rf_data_reg;
reg [31:0] load_dmem_out_data_reg;

// Store Regs
reg [7:0] store_ir_transid_reg;
reg [7:0] store_dmem_transid_reg;
reg [31:0] store_mem_addr_reg;
reg [31:0] store_mem_addr;
reg [31:0] dmemreq_msg_data_Mhl;
reg [31:0] dmemreq_msg_data_Whl;
reg [31:0] rs2_data_reg;

// Wire definitions
wire [31:0] rs1_data = dpath.rf_rdata0_Dhl;
wire [31:0] rs2_data = dpath.rf_rdata1_Dhl;

// Parse the opcode
wire [31:25] func7_t = ctrl.ir_Dhl[31:25]; 
wire [31:0] i_immediate_12_bits = {{20{ctrl.ir_Dhl[31]}}, ctrl.ir_Dhl[31:20]};
wire [31:0] i_immediate_12_bits_store = {{20{ctrl.ir_Dhl[31]}}, ctrl.ir_Dhl[31:25], ctrl.ir_Dhl[11:7]};
wire [24:20] i_immediate_5_bits = ctrl.ir_Dhl[24:20];
wire [24:20] rs2 = ctrl.ir_Dhl[24:20]; 
wire [19:15] rs1 = ctrl.ir_Dhl[19:15]; 
wire [14:12] rtype_funct3_t = ctrl.ir_Dhl[14:12]; 
wire [11:7] rd = ctrl.ir_Dhl[11:7]; 
wire [6:0] opcode_t = ctrl.ir_Dhl[6:0];

// Determine type of instruction
riscv_Instructions instructions_decode
(
	.instr(ctrl.ir_Dhl),
	.type_add_instr(type_add_instr_Dhl),
    .type_sub_instr(type_sub_instr_Dhl),
    .type_sll_instr(type_sll_instr_Dhl),
    .type_slt_instr(type_slt_instr_Dhl),
    .type_sltu_instr(type_sltu_instr_Dhl),
    .type_xor_instr(type_xor_instr_Dhl),
    .type_srl_instr(type_srl_instr_Dhl),
    .type_sra_instr(type_sra_instr_Dhl),
    .type_or_instr(type_or_instr_Dhl),
    .type_and_instr(type_and_instr_Dhl),
	.type_addi_instr(type_addi_instr_Dhl),
    .type_slli_instr(type_slli_instr_Dhl),
    .type_slti_instr(type_slti_instr_Dhl),
    .type_sltiu_instr(type_sltiu_instr_Dhl),
    .type_xori_instr(type_xori_instr_Dhl),
    .type_srli_instr(type_srli_instr_Dhl),
    .type_srai_instr(type_srai_instr_Dhl),
    .type_ori_instr(type_ori_instr_Dhl),
    .type_andi_instr(type_andi_instr_Dhl),
	.type_lw_instr(type_lw_instr_Dhl),
	.type_lb_instr(type_lb_instr_Dhl),
    .type_lh_instr(type_lh_instr_Dhl),
    .type_lbu_instr(type_lbu_instr_Dhl),
    .type_lhu_instr(type_lhu_instr_Dhl),
	.type_sw_instr(type_sw_instr_Dhl),
	.type_sb_instr(type_sb_instr_Dhl),
	.type_sh_instr(type_sh_instr_Dhl)
); 

// Parse the instruction in the M stage
riscv_Instructions instructions_memory
(
	.instr(ctrl.ir_Mhl),
	.type_lw_instr(type_lw_instr_Mhl),
	.type_lb_instr(type_lb_instr_Mhl),
    .type_lh_instr(type_lh_instr_Mhl),
    .type_lbu_instr(type_lbu_instr_Mhl),
    .type_lhu_instr(type_lhu_instr_Mhl),
	.type_sw_instr(type_sw_instr_Mhl),
	.type_sb_instr(type_sb_instr_Mhl),
	.type_sh_instr(type_sh_instr_Mhl)
); 

// Parse the instruction in the W stage
riscv_Instructions instructions_writeback
(
	.instr(ctrl.ir_Whl),
	.type_add_instr(type_add_instr_Whl),
    .type_sub_instr(type_sub_instr_Whl),
    .type_sll_instr(type_sll_instr_Whl),
    .type_slt_instr(type_slt_instr_Whl),
    .type_sltu_instr(type_sltu_instr_Whl),
    .type_xor_instr(type_xor_instr_Whl),
    .type_srl_instr(type_srl_instr_Whl),
    .type_sra_instr(type_sra_instr_Whl),
    .type_or_instr(type_or_instr_Whl),
    .type_and_instr(type_and_instr_Whl),
	.type_addi_instr(type_addi_instr_Whl),
    .type_slli_instr(type_slli_instr_Whl),
    .type_slti_instr(type_slti_instr_Whl),
    .type_sltiu_instr(type_sltiu_instr_Whl),
    .type_xori_instr(type_xori_instr_Whl),
    .type_srli_instr(type_srli_instr_Whl),
    .type_srai_instr(type_srai_instr_Whl),
    .type_ori_instr(type_ori_instr_Whl),
    .type_andi_instr(type_andi_instr_Whl),
	.type_lw_instr(type_lw_instr_Whl),
	.type_lb_instr(type_lb_instr_Whl),
    .type_lh_instr(type_lh_instr_Whl),
    .type_lbu_instr(type_lbu_instr_Whl),
    .type_lhu_instr(type_lhu_instr_Whl),
	.type_sw_instr(type_sw_instr_Whl),
	.type_sb_instr(type_sb_instr_Whl),
	.type_sh_instr(type_sh_instr_Whl)
);

wire type_alu_r_instr_Dhl = type_add_instr_Dhl || 
							type_sub_instr_Dhl || 
							type_sll_instr_Dhl || 
							type_slt_instr_Dhl ||
							type_sltu_instr_Dhl ||
							type_xor_instr_Dhl ||
							type_srl_instr_Dhl ||
							type_sra_instr_Dhl ||
							type_or_instr_Dhl ||
							type_and_instr_Dhl;

wire type_alu_r_instr_Whl = type_add_instr_Whl || 
							type_sub_instr_Whl || 
							type_sll_instr_Whl || 
							type_slt_instr_Whl ||
							type_sltu_instr_Whl ||
							type_xor_instr_Whl ||
							type_srl_instr_Whl ||
							type_sra_instr_Whl ||
							type_or_instr_Whl ||
							type_and_instr_Whl;

wire type_alu_i_instr_Dhl = type_addi_instr_Dhl || 
							type_slli_instr_Dhl || 
							type_slti_instr_Dhl ||
							type_sltiu_instr_Dhl ||
							type_xori_instr_Dhl ||
							type_srli_instr_Dhl ||
							type_srai_instr_Dhl ||
							type_ori_instr_Dhl ||
							type_andi_instr_Dhl;

wire type_alu_i_instr_Whl = type_addi_instr_Whl || 
							type_slli_instr_Whl || 
							type_slti_instr_Whl ||
							type_sltiu_instr_Whl ||
							type_xori_instr_Whl ||
							type_srli_instr_Whl ||
							type_srai_instr_Whl ||
							type_ori_instr_Whl ||
							type_andi_instr_Whl;

assign type_load_instr_Dhl = type_lw_instr_Dhl || type_lb_instr_Dhl || type_lh_instr_Dhl || type_lbu_instr_Dhl || type_lhu_instr_Dhl;
assign type_load_instr_Mhl = type_lw_instr_Mhl || type_lb_instr_Mhl || type_lh_instr_Mhl || type_lbu_instr_Mhl || type_lhu_instr_Mhl;
assign type_load_instr_Whl = type_lw_instr_Whl || type_lb_instr_Whl || type_lh_instr_Whl || type_lbu_instr_Whl || type_lhu_instr_Whl;

assign type_store_instr_Dhl = type_sw_instr_Dhl;
assign type_store_instr_Mhl = type_sw_instr_Mhl;
assign type_store_instr_Whl = type_sw_instr_Whl;

// Calculate expected ALU output
always_comb begin
	alu_output = 32'bx;
	unsigned_a = (rs1_data[31] ?  ~rs1_data + 1'b1 : rs1_data); 
	unsigned_b = (rs2_data[31] ?  ~rs2_data + 1'b1 : rs2_data);
	load_mem_addr = 32'bx; 
	store_mem_addr = 32'bx;
	// ALU R type instructions
	if (type_add_instr_Dhl) begin
		alu_output = rs1_data + rs2_data;
	end 
	if (type_sub_instr_Dhl) begin
		alu_output = rs1_data - rs2_data;
	end 
	if (type_sll_instr_Dhl) begin
		alu_output = rs1_data << rs2_data[4:0];
	end 
	if (type_slt_instr_Dhl) begin 
		alu_output = ($signed(rs1_data) < $signed(rs2_data));
	end
	if (type_sltu_instr_Dhl) begin
		alu_output = ($unsigned(rs1_data) < $unsigned(rs2_data));
	end
	if (type_xor_instr_Dhl) begin
		alu_output = (rs1_data ^ rs2_data); 
	end
	if (type_srl_instr_Dhl) begin
		alu_output = rs1_data >> rs2_data[4:0];
	end
	if (type_sra_instr_Dhl) begin
		alu_output =  $signed(rs1_data) >>> rs2_data[4:0];
	end
	if (type_or_instr_Dhl) begin
		alu_output = (rs1_data | rs2_data);
	end
	if (type_and_instr_Dhl) begin
		alu_output = (rs1_data & rs2_data);
	end

	// ALU I type instructions
	if (type_addi_instr_Dhl) begin
		alu_output = rs1_data + i_immediate_12_bits;
	end 
	if (type_slli_instr_Dhl) begin
		alu_output = rs1_data << i_immediate_5_bits;
	end 
	if (type_slti_instr_Dhl) begin 
		alu_output = ($signed(rs1_data) < $signed(i_immediate_12_bits));
	end

	if (type_sltiu_instr_Dhl) begin
		alu_output = ($unsigned(rs1_data) < $unsigned(i_immediate_12_bits));
	end
	if (type_xori_instr_Dhl) begin
		alu_output = (rs1_data ^ $signed(i_immediate_12_bits)); 
	end
	if (type_srli_instr_Dhl) begin
		alu_output = rs1_data >> i_immediate_5_bits;
	end
	if (type_srai_instr_Dhl) begin
		alu_output =  $signed(rs1_data) >>> i_immediate_5_bits;
	end
	if (type_ori_instr_Dhl) begin
		alu_output = (rs1_data | $signed(i_immediate_12_bits));
	end
	if (type_andi_instr_Dhl) begin
		alu_output = (rs1_data & $signed(i_immediate_12_bits));
	end

	// Calculate the load address
	if (type_load_instr_Dhl) begin
		load_mem_addr = (rs1_data + $signed(i_immediate_12_bits));
	end

	// Calculate the store address
	if (type_store_instr_Dhl) begin
		store_mem_addr = (rs1_data + $signed(i_immediate_12_bits_store));
	end
	
end 

// Implement flip-flops needed for data integrity checks
always_ff @(posedge clk) begin
	stall_Dhl_reg <= ctrl.stall_Dhl; 
	stall_Mhl_reg <= ctrl.stall_Mhl;
end

always_ff @(posedge clk) begin
	if (reset) begin
		ir_transid_reg <= 8'b0; 
		rf_transid_reg <= 8'b0;
		load_ir_transid_reg <= 8'b0; 
		load_dmem_transid_reg <= 8'b0; 
		load_dmem_out_transid_reg <= 8'b0;
		load_rf_transid_reg <= 8'b0;
		store_ir_transid_reg <= 8'b0;
		store_dmem_transid_reg <= 8'b0; 
	end else begin
		if (ir_val && ir_rdy) begin
			ir_transid_reg <= ir_transid_reg + 8'b1; 
		end

		if (load_ir_val && load_ir_rdy) begin
			load_ir_transid_reg <= load_ir_transid_reg + 8'b1; 
		end

		if (load_dmem_val && load_dmem_rdy) begin
			load_dmem_transid_reg <= load_dmem_transid_reg + 8'b1; 
		end

		if (rf_val && rf_rdy) begin
			rf_transid_reg <= rf_transid_reg + 8'b1; 
		end

		if (load_rf_rdy && load_rf_val) begin
			load_rf_transid_reg <= load_rf_transid_reg + 8'b1;
		end

		if (load_dmem_out_rdy && load_dmem_out_val) begin
			load_dmem_out_transid_reg <= load_dmem_out_transid_reg + 8'b1;
		end

		if (store_ir_val && store_ir_rdy) begin 
			store_ir_transid_reg <= store_ir_transid_reg + 8'b1; 
		end

		if (store_dmem_rdy && store_dmem_val) begin
			store_dmem_transid_reg <= store_dmem_transid_reg + 8'b1; 
		end
	end
end

always_ff @(posedge clk) begin
	if (reset) begin
		ir_Dhl_prev <= 32'b0; 
	end else begin
		ir_Dhl_prev <= ctrl.ir_Dhl; 
	end
end

always @(posedge clk) begin
	if (reset) begin
		alu_output_reg <= 32'b0;
		load_dmemreq_msg_addr_Mhl <= 32'b0; 
		store_dmemreq_msg_addr_Mhl <= 32'b0; 
		load_dmemreq_msg_addr_Whl <= 32'b0;
		store_dmemreq_msg_addr_Whl <= 32'b0;
		rf_data_reg <= 32'b0;
		rd_reg <= 5'b0;
		rf_waddr_Whl_reg <= 5'b0;
		load_mem_addr_reg <= 32'b0;
		store_mem_addr_reg <= 32'b0;
		dmemreq_val_Mhl <= 1'b0;
		dmemreq_rdy_Mhl <= 1'b0;
		load_dmem_out_data_reg <= 32'b0;
		load_rf_data_reg <= 32'b0;
	end

	else begin
		if (ir_val) begin
			alu_output_reg <= alu_output;
			rd_reg <= rd;
		end

		if (load_ir_val) begin
			load_mem_addr_reg <= load_mem_addr;
		end 

		if (store_ir_val) begin
			store_mem_addr_reg <= store_mem_addr;
			rs2_data_reg <= rs2_data;
		end 

		if (!ctrl.stall_Xhl && dmemreq_msg_rw_Xhl)  begin
			load_dmemreq_msg_addr_Mhl <= dpath.dmemreq_msg_addr;
		end

		if (!ctrl.stall_Xhl && (dmemreq_msg_rw_Xhl == 2'd2))  begin
			store_dmemreq_msg_addr_Mhl <= dpath.dmemreq_msg_addr;
			dmemreq_msg_data_Mhl <= dpath.dmemreq_msg_data;
		end

		if (load_dmem_val) begin
			load_dmemreq_msg_addr_Whl <= load_dmemreq_msg_addr_Mhl;
		end

		if (store_dmem_val) begin
			store_dmemreq_msg_addr_Whl <= store_dmemreq_msg_addr_Mhl;
			dmemreq_msg_data_Whl <= dmemreq_msg_data_Mhl;
		end

		if (rf_val) begin
			rf_data_reg <= dpath.wb_mux_out_Whl;
			rf_waddr_Whl_reg <= dpath.rf_waddr_Whl;
		end
		if (ctrl.inst_val_Dhl && !ctrl.stall_Xhl) begin
			dmemreq_msg_rw_Xhl <= ctrl.cs[`RISCV_INST_MSG_MEM_REQ]; 
		end

		if (ctrl.inst_val_Xhl && !ctrl.stall_Mhl) begin // MAYBE THE END OF ALL THE WORLD
			dmemreq_msg_rw_Mhl <= dmemreq_msg_rw_Xhl; 
			dmemreq_val_Mhl <= ctrl.dmemreq_val_Xhl;
			dmemreq_rdy_Mhl <= ctrl.dmemreq_rdy;
		end

		if (load_dmem_out_val) begin
			if (type_lw_instr_Mhl)
				load_dmem_out_data_reg <= dpath.dmemresp_msg_data;
			else if (type_lb_instr_Mhl)
				load_dmem_out_data_reg <= {{24{dpath.dmemresp_msg_data[7]}}, dpath.dmemresp_msg_data[7:0]};
			else if (type_lh_instr_Mhl)
				load_dmem_out_data_reg <= {{16{dpath.dmemresp_msg_data[15]}}, dpath.dmemresp_msg_data[15:0]};
			else if (type_lbu_instr_Mhl)
				load_dmem_out_data_reg <= {{24{1'b0}}, dpath.dmemresp_msg_data[7:0]};
			else if (type_lhu_instr_Mhl)
				load_dmem_out_data_reg <= {{16{1'b0}}, dpath.dmemresp_msg_data[15:0]};
		end

		if (load_rf_val) begin
			load_rf_data_reg <= dpath.wb_mux_out_Whl;
		end
	end
end

// Assumptions
// Assume valid opcode
am_val_instr: assume property (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl || type_load_instr_Dhl || type_store_instr_Dhl);

// Assume that the imemreq and imemresp_val happen at the same cycle
am_imemreq_imemval_same_cycle: assume property (!imemreq_val |-> !imemresp_val);

// Assume that the data memory will eventually become ready after a request is made
am_dmemreq_val_eventually: assume property (ctrl.dmemreq_val_Xhl |-> s_eventually dmemreq_rdy);

// Assume that eventually dmem will give a valid response 
am_dmemreq_imemval_same_cycle: assume property (dmemreq_val |-> ##1 dmemresp_val);

// Assertions
// Assert that the read ports to the register file match  rs1 and rs2 from the opcode
as_rs1_match: assert property ((type_alu_r_instr_Dhl || type_alu_i_instr_Dhl || type_load_instr_Dhl || type_store_instr_Dhl) && ctrl.inst_val_Dhl |-> (rs1 == dpath.rf_raddr0_Dhl));
as_rs2_match: assert property ((type_alu_r_instr_Dhl || type_alu_i_instr_Dhl || type_store_instr_Dhl) && ctrl.inst_val_Dhl |-> (rs2 == dpath.rf_raddr1_Dhl)); 

// Assert that rd in W stage matches rd of the decoded instruction for the same transid
as__ir_rf_trans_transid_data_integrity_rd: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response && (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl || type_load_instr_Dhl) |-> (rf_waddr_Whl_reg == ir_rf_trans_transid_data_model_rd));

// Stores: Assert that data written to memory matches value read from rs2
as__store_ir_dmem_trans_transid_data_integrity_rs2: assert property (|store_ir_dmem_trans_transid_sampled && store_ir_dmem_trans_transid_response && type_store_instr_Whl |-> (dmemreq_msg_data_Whl == store_ir_dmem_trans_transid_data_model_rs2));

endmodule