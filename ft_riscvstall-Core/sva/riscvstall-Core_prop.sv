// This property file was autogenerated by AutoSVA on 2024-04-27
// to check the behavior of the original RTL module, whose interface is described below: 


`include "../../ece475-lab2/vc/vc-MemReqMsg.v"
`include "../../ece475-lab2/vc/vc-MemRespMsg.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreCtrl.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreDpath.v"
`include "../../ece475-lab2/riscvstall/riscvstall-InstMsg.v"
`include "../../ece475-lab2/riscvstall/riscvstall-Instructions.v"


module riscv_Core_prop
#(
		parameter ASSERT_INPUTS = 0)
(
		
		input         clk,
		input         reset,
		
		// Instruction Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] imemreq_msg, //output
		input                                  imemreq_val, //output
		input                                  imemreq_rdy,
		
		// Instruction Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] imemresp_msg,
		input                               imemresp_val,
		
		// Data Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] dmemreq_msg, //output
		input                                  dmemreq_val, //output
		input                                  dmemreq_rdy,
		
		// Data Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] dmemresp_msg,
		input                               dmemresp_val,
		
		// CSR Status Register Output to Host
		
		input  [31:0] csr_status //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (reset);

// Re-defined wires 
wire [7:0] ir_transid;
wire [7:0] rf_transid;
wire rf_val;
wire rf_rdy;
wire ir_val;
wire ir_rdy;
wire [31:0] ir_data;
wire [31:0] rf_data;
wire [7:0] load_ir_transid;
wire [7:0] load_dmem_transid;
wire load_ir_rdy;
wire load_ir_val;
wire load_dmem_rdy;
wire load_dmem_val;
wire [31:0] load_ir_data;
wire [31:0] load_dmem_data;

// Symbolics and Handshake signals
wire [7:0] symb_ir_transid;
am__symb_ir_transid_stable: assume property($stable(symb_ir_transid));
wire rf_hsk = rf_val && rf_rdy;
wire ir_hsk = ir_val && ir_rdy;
wire [7:0] symb_load_ir_transid;
am__symb_load_ir_transid_stable: assume property($stable(symb_load_ir_transid));
wire load_dmem_hsk = load_dmem_val && load_dmem_rdy;
wire load_ir_hsk = load_ir_val && load_ir_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for ir_rf_trans
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_fairness: assert property (rf_val |-> s_eventually(rf_rdy));
end else begin
	am__ir_rf_trans_fairness: assume property (rf_val |-> s_eventually(rf_rdy));
end

// Generate sampling signals and model
reg [3:0] ir_rf_trans_transid_sampled;
wire ir_rf_trans_transid_set = ir_hsk && ir_transid == symb_ir_transid;

wire ir_rf_trans_transid_response = rf_hsk && ((rf_transid == symb_ir_transid) && (symb_ir_transid != 8'b0));

always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_sampled <= '0;
	end else if (ir_rf_trans_transid_set || ir_rf_trans_transid_response ) begin
		ir_rf_trans_transid_sampled <= ir_rf_trans_transid_sampled + ir_rf_trans_transid_set - ir_rf_trans_transid_response;
	end
end
co__ir_rf_trans_transid_sampled: cover property (|ir_rf_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_transid_sample_no_overflow: assert property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end else begin
	am__ir_rf_trans_transid_sample_no_overflow: assume property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__ir_rf_trans_transid_hsk_or_drop: assert property (ir_val |-> s_eventually(!ir_val || ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__ir_rf_trans_transid_eventual_response: assert property (|ir_rf_trans_transid_sampled && (symb_ir_transid != 32'b0) |-> s_eventually(rf_val && (rf_transid == symb_ir_transid) ));
as__ir_rf_trans_transid_was_a_request: assert property (ir_rf_trans_transid_response |-> ir_rf_trans_transid_set || ir_rf_trans_transid_sampled);


// Modeling data integrity for ir_rf_trans_transid
reg [32:0] ir_rf_trans_transid_data_model;
reg [32:0] ir_rf_trans_transid_data_model_rd;
always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_data_model <= '0;
		ir_rf_trans_transid_data_model_rd <= 'b0; 
	end else if (ir_rf_trans_transid_set) begin
		ir_rf_trans_transid_data_model <= ir_data;
		ir_rf_trans_transid_data_model_rd <= rd_reg;
	end
end

as__ir_rf_trans_transid_data_unique: assert property (|ir_rf_trans_transid_sampled  && (symb_ir_transid != 32'b0) |-> !ir_rf_trans_transid_set);
as__ir_rf_trans_transid_data_integrity: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response |-> (rf_data == ir_rf_trans_transid_data_model));

// Modeling incoming request for load_ir_dmem_trans
if (ASSERT_INPUTS) begin
	as__load_ir_dmem_trans_fairness: assert property (load_dmem_val |-> s_eventually(load_dmem_rdy));
end else begin
	am__load_ir_dmem_trans_fairness: assume property (load_dmem_val |-> s_eventually(load_dmem_rdy));
end

// Generate sampling signals and model
reg [3:0] load_ir_dmem_trans_transid_sampled;
wire load_ir_dmem_trans_transid_set = load_ir_hsk && load_ir_transid == symb_load_ir_transid;
wire load_ir_dmem_trans_transid_response = load_dmem_hsk && (load_dmem_transid == symb_load_ir_transid) && (symb_load_ir_transid != 8'b0);

always_ff @(posedge clk) begin
	if(reset) begin
		load_ir_dmem_trans_transid_sampled <= '0;
	end else if (load_ir_dmem_trans_transid_set || load_ir_dmem_trans_transid_response ) begin
		load_ir_dmem_trans_transid_sampled <= load_ir_dmem_trans_transid_sampled + load_ir_dmem_trans_transid_set - load_ir_dmem_trans_transid_response;
	end
end
co__load_ir_dmem_trans_transid_sampled: cover property (|load_ir_dmem_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__load_ir_dmem_trans_transid_sample_no_overflow: assert property (load_ir_dmem_trans_transid_sampled != '1 || !load_ir_dmem_trans_transid_set);
end else begin
	am__load_ir_dmem_trans_transid_sample_no_overflow: assume property (load_ir_dmem_trans_transid_sampled != '1 || !load_ir_dmem_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__load_ir_dmem_trans_transid_hsk_or_drop: assert property (load_ir_val |-> s_eventually(!load_ir_val || load_ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__load_ir_dmem_trans_transid_eventual_response: assert property (|load_ir_dmem_trans_transid_sampled && (symb_load_ir_transid != 32'b0) |-> s_eventually(load_dmem_val && (load_dmem_transid == symb_load_ir_transid) ));
as__load_ir_dmem_trans_transid_was_a_request: assert property (load_ir_dmem_trans_transid_response |-> load_ir_dmem_trans_transid_set || load_ir_dmem_trans_transid_sampled);


// Modeling data integrity for load_ir_dmem_trans_transid
reg [31:0] load_ir_dmem_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		load_ir_dmem_trans_transid_data_model <= '0;
	end else if (load_ir_dmem_trans_transid_set) begin
		load_ir_dmem_trans_transid_data_model <= load_ir_data;
	end
end

as__load_ir_dmem_trans_transid_data_unique: assert property (|load_ir_dmem_trans_transid_sampled  && (symb_load_ir_transid != 32'b0) |-> !load_ir_dmem_trans_transid_set);
as__load_ir_dmem_trans_transid_data_integrity: assert property (|load_ir_dmem_trans_transid_sampled && load_ir_dmem_trans_transid_response |-> (load_dmem_data == load_ir_dmem_trans_transid_data_model));

assign load_ir_transid = load_ir_transid_reg;
assign ir_data = alu_output_reg;
assign ir_rdy = !stall_Dhl_reg;
assign ir_val = ctrl.inst_val_Dhl && (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl);
// assign ir_val = ctrl.inst_val_Dhl ? ((type_alu_r_instr_Dhl || type_alu_i_instr_Dhl) ? 1'b1 : 1'b0) : ir_val;
assign rf_data = rf_data_reg;
assign rf_transid = rf_transid_reg;
assign load_ir_data = mem_addr_reg;
assign load_dmem_transid = load_dmem_transid_reg;
assign load_dmem_data = dmemreq_msg_addr_Whl;
assign load_dmem_rdy = dmemreq_rdy_Mhl;
assign rf_rdy = 1'b1;
assign load_ir_val = ctrl.inst_val_Dhl && type_load_instr_Dhl;
assign rf_val = ctrl.inst_val_Whl && ctrl.rf_wen_Whl && (type_alu_r_instr_Whl || type_alu_i_instr_Whl);
// assign rf_val = (ctrl.inst_val_Whl && ctrl.rf_wen_Whl) ? ((type_alu_r_instr_Whl || type_alu_i_instr_Whl) ? 1'b1 : 1'b0) : rf_val;
assign ir_transid = ir_transid_reg;
assign load_dmem_val = ctrl.inst_val_Mhl && (dmemreq_msg_rw_Mhl && dmemreq_val_Mhl) && type_load_instr_Mhl && !stall_Mhl_reg;
// assign load_dmem_val = dmemreq_val && core.dmemreq_msg_rw;
assign load_ir_rdy = !stall_Dhl_reg;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_rf_val: assert property(!$isunknown(rf_val));
	 as__no_x_rf_data: assert property(rf_val |-> !$isunknown(rf_data));
	 as__no_x_rf_transid: assert property(rf_val |-> !$isunknown(rf_transid));
	 as__no_x_ir_val: assert property(!$isunknown(ir_val));
	 as__no_x_ir_data: assert property(ir_val |-> !$isunknown(ir_data));
	 as__no_x_ir_transid: assert property(ir_val |-> !$isunknown(ir_transid));
	 as__no_x_load_ir_val: assert property(!$isunknown(load_ir_val));
	 as__no_x_load_ir_transid: assert property(load_ir_val |-> !$isunknown(load_ir_transid));
	 as__no_x_load_ir_data: assert property(load_ir_val |-> !$isunknown(load_ir_data));
	 as__no_x_load_dmem_val: assert property(!$isunknown(load_dmem_val));
	 as__no_x_load_dmem_data: assert property(load_dmem_val |-> !$isunknown(load_dmem_data));
	 as__no_x_load_dmem_transid: assert property(load_dmem_val |-> !$isunknown(load_dmem_transid));
`endif

//====DESIGNER-ADDED-SVA====//
// Type of instruction wires
// ALU R-type
wire type_add_instr_Dhl;
wire type_sub_instr_Dhl;
wire type_sll_instr_Dhl;
wire type_slt_instr_Dhl;
wire type_sltu_instr_Dhl;
wire type_xor_instr_Dhl;
wire type_srl_instr_Dhl;
wire type_sra_instr_Dhl;
wire type_or_instr_Dhl;
wire type_and_instr_Dhl;

wire type_add_instr_Whl;
wire type_sub_instr_Whl;
wire type_sll_instr_Whl;
wire type_slt_instr_Whl;
wire type_sltu_instr_Whl;
wire type_xor_instr_Whl;
wire type_srl_instr_Whl;
wire type_sra_instr_Whl;
wire type_or_instr_Whl;
wire type_and_instr_Whl;

// ALU I-type
wire type_addi_instr_Dhl;
wire type_slti_instr_Dhl;
wire type_sltiu_instr_Dhl;
wire type_xori_instr_Dhl;
wire type_ori_instr_Dhl;
wire type_andi_instr_Dhl;
wire type_slli_instr_Dhl;
wire type_srli_instr_Dhl;
wire type_srai_instr_Dhl;

wire type_addi_instr_Whl;
wire type_slti_instr_Whl;
wire type_sltiu_instr_Whl;
wire type_xori_instr_Whl;
wire type_ori_instr_Whl;
wire type_andi_instr_Whl;
wire type_slli_instr_Whl;
wire type_srli_instr_Whl;
wire type_srai_instr_Whl;

// Load
wire type_lw_instr_Dhl;
wire type_load_instr_Mhl;
wire type_lw_instr_Whl;

// Register definitons
reg [7:0] ir_transid_reg;
reg [7:0] rf_transid_reg; 
reg [31:0] rf_data_reg;
reg stall_Dhl_reg;
reg stall_Mhl_reg; 
reg [4:0] rd_reg;
reg [4:0] rf_waddr_Whl_reg;
reg [31:0] alu_output; 
reg [31:0] alu_output_reg;
reg [31:0] ir_Dhl_prev;
reg [31:0] ir_Xhl;
reg [31:0] ir_Mhl;
reg [31:0] ir_Whl;

// Unsigned wires for muldiv
reg [31:0] unsigned_a;
reg [31:0] unsigned_b;
reg [31:0] unsigned_res;

// Load Regs 
reg dmemreq_msg_rw_Mhl;
reg dmemreq_msg_rw_Xhl;
reg [31:0] mem_addr_reg;
reg [7:0] load_ir_transid_reg;
reg [7:0] load_dmem_transid_reg; 
reg [31:0] mem_addr; 
reg dmemreq_val_Mhl;
reg dmemreq_rdy_Mhl;
reg [31:0] dmemreq_msg_addr_Mhl;
reg [31:0] dmemreq_msg_addr_Whl; 

// Wire definitions
wire [31:0] rs1_data = dpath.rf_rdata0_Dhl;
wire [31:0] rs2_data = dpath.rf_rdata1_Dhl;

// Parse the opcode
wire [31:25] func7_t = ctrl.ir_Dhl[31:25]; 
wire [31:0] i_immediate_12_bits = {{20{ctrl.ir_Dhl[31]}}, ctrl.ir_Dhl[31:20]};
wire [24:20] i_immediate_5_bits = ctrl.ir_Dhl[24:20];
wire [24:20] rs2 = ctrl.ir_Dhl[24:20]; 
wire [19:15] rs1 = ctrl.ir_Dhl[19:15]; 
wire [14:12] rtype_funct3_t = ctrl.ir_Dhl[14:12]; 
wire [11:7] rd = ctrl.ir_Dhl[11:7]; 
wire [6:0] opcode_t = ctrl.ir_Dhl[6:0];

// Determine type of instruction
riscv_Instructions instructions_decode
(
	.instr(ctrl.ir_Dhl),
	.type_add_instr(type_add_instr_Dhl),
    .type_sub_instr(type_sub_instr_Dhl),
    .type_sll_instr(type_sll_instr_Dhl),
    .type_slt_instr(type_slt_instr_Dhl),
    .type_sltu_instr(type_sltu_instr_Dhl),
    .type_xor_instr(type_xor_instr_Dhl),
    .type_srl_instr(type_srl_instr_Dhl),
    .type_sra_instr(type_sra_instr_Dhl),
    .type_or_instr(type_or_instr_Dhl),
    .type_and_instr(type_and_instr_Dhl),
	.type_addi_instr(type_addi_instr_Dhl),
    .type_slli_instr(type_slli_instr_Dhl),
    .type_slti_instr(type_slti_instr_Dhl),
    .type_sltiu_instr(type_sltiu_instr_Dhl),
    .type_xori_instr(type_xori_instr_Dhl),
    .type_srli_instr(type_srli_instr_Dhl),
    .type_srai_instr(type_srai_instr_Dhl),
    .type_ori_instr(type_ori_instr_Dhl),
    .type_andi_instr(type_andi_instr_Dhl),
	.type_lw_instr(type_lw_instr_Dhl)
); 

// Parse the instruction in the M stage
riscv_Instructions instructions_memory
(
	.instr(ctrl.ir_Mhl),
	.type_lw_instr(type_lw_instr_Mhl)
); 

// Parse the instruction in the W stage
riscv_Instructions instructions_writeback
(
	.instr(ctrl.ir_Whl),
	.type_add_instr(type_add_instr_Whl),
    .type_sub_instr(type_sub_instr_Whl),
    .type_sll_instr(type_sll_instr_Whl),
    .type_slt_instr(type_slt_instr_Whl),
    .type_sltu_instr(type_sltu_instr_Whl),
    .type_xor_instr(type_xor_instr_Whl),
    .type_srl_instr(type_srl_instr_Whl),
    .type_sra_instr(type_sra_instr_Whl),
    .type_or_instr(type_or_instr_Whl),
    .type_and_instr(type_and_instr_Whl),
	.type_addi_instr(type_addi_instr_Whl),
    .type_slli_instr(type_slli_instr_Whl),
    .type_slti_instr(type_slti_instr_Whl),
    .type_sltiu_instr(type_sltiu_instr_Whl),
    .type_xori_instr(type_xori_instr_Whl),
    .type_srli_instr(type_srli_instr_Whl),
    .type_srai_instr(type_srai_instr_Whl),
    .type_ori_instr(type_ori_instr_Whl),
    .type_andi_instr(type_andi_instr_Whl),
	.type_lw_instr(type_lw_instr_Whl)
);

wire type_alu_r_instr_Dhl = type_add_instr_Dhl || 
							type_sub_instr_Dhl || 
							type_sll_instr_Dhl || 
							type_slt_instr_Dhl ||
							type_sltu_instr_Dhl ||
							type_xor_instr_Dhl ||
							type_srl_instr_Dhl ||
							type_sra_instr_Dhl ||
							type_or_instr_Dhl ||
							type_and_instr_Dhl;

wire type_alu_r_instr_Whl = type_add_instr_Whl || 
							type_sub_instr_Whl || 
							type_sll_instr_Whl || 
							type_slt_instr_Whl ||
							type_sltu_instr_Whl ||
							type_xor_instr_Whl ||
							type_srl_instr_Whl ||
							type_sra_instr_Whl ||
							type_or_instr_Whl ||
							type_and_instr_Whl;

wire type_alu_i_instr_Dhl = type_addi_instr_Dhl || 
							type_slli_instr_Dhl || 
							type_slti_instr_Dhl ||
							type_sltiu_instr_Dhl ||
							type_xori_instr_Dhl ||
							type_srli_instr_Dhl ||
							type_srai_instr_Dhl ||
							type_ori_instr_Dhl ||
							type_andi_instr_Dhl;

wire type_alu_i_instr_Whl = type_addi_instr_Whl || 
							type_slli_instr_Whl || 
							type_slti_instr_Whl ||
							type_sltiu_instr_Whl ||
							type_xori_instr_Whl ||
							type_srli_instr_Whl ||
							type_srai_instr_Whl ||
							type_ori_instr_Whl ||
							type_andi_instr_Whl;

assign type_load_instr_Dhl = type_lw_instr_Dhl;
assign type_load_instr_Mhl = type_lw_instr_Mhl;
assign type_load_instr_Whl = type_lw_instr_Whl;

// Calculate expected ALU output
always_comb begin
	alu_output = 32'bx;
	unsigned_a = (rs1_data[31] ?  ~rs1_data + 1'b1 : rs1_data); 
	unsigned_b = (rs2_data[31] ?  ~rs2_data + 1'b1 : rs2_data);
	mem_addr = 32'bx; 
	// ALU R type instructions
	if (type_add_instr_Dhl) begin
		alu_output = rs1_data + rs2_data;
	end 
	if (type_sub_instr_Dhl) begin
		alu_output = rs1_data - rs2_data;
	end 
	if (type_sll_instr_Dhl) begin
		alu_output = rs1_data << rs2_data[4:0];
	end 
	if (type_slt_instr_Dhl) begin 
		alu_output = ($signed(rs1_data) < $signed(rs2_data));
	end
	if (type_sltu_instr_Dhl) begin
		alu_output = ($unsigned(rs1_data) < $unsigned(rs2_data));
	end
	if (type_xor_instr_Dhl) begin
		alu_output = (rs1_data ^ rs2_data); 
	end
	if (type_srl_instr_Dhl) begin
		alu_output = rs1_data >> rs2_data[4:0];
	end
	if (type_sra_instr_Dhl) begin
		alu_output =  $signed(rs1_data) >>> rs2_data[4:0];
	end
	if (type_or_instr_Dhl) begin
		alu_output = (rs1_data | rs2_data);
	end
	if (type_and_instr_Dhl) begin
		alu_output = (rs1_data & rs2_data);
	end

	// ALU I type instructions
	if (type_addi_instr_Dhl) begin
		alu_output = rs1_data + i_immediate_12_bits;
	end 
	if (type_slli_instr_Dhl) begin
		alu_output = rs1_data << i_immediate_5_bits;
	end 
	if (type_slti_instr_Dhl) begin 
		alu_output = ($signed(rs1_data) < $signed(i_immediate_12_bits));
	end

	if (type_sltiu_instr_Dhl) begin
		alu_output = ($unsigned(rs1_data) < $unsigned(i_immediate_12_bits));
	end
	if (type_xori_instr_Dhl) begin
		alu_output = (rs1_data ^ $signed(i_immediate_12_bits)); 
	end
	if (type_srli_instr_Dhl) begin
		alu_output = rs1_data >> i_immediate_5_bits;
	end
	if (type_srai_instr_Dhl) begin
		alu_output =  $signed(rs1_data) >>> i_immediate_5_bits;
	end
	if (type_ori_instr_Dhl) begin
		alu_output = (rs1_data | $signed(i_immediate_12_bits));
	end
	if (type_andi_instr_Dhl) begin
		alu_output = (rs1_data & $signed(i_immediate_12_bits));
	end

	// Calculate the load address
	if (type_lw_instr_Dhl) begin
		mem_addr = (rs1_data + $signed(i_immediate_12_bits));
	end
	
end 

// Implement flip-flops needed for data integrity checks
always_ff @(posedge clk) begin
	stall_Dhl_reg <= ctrl.stall_Dhl; 
	stall_Mhl_reg <= ctrl.stall_Mhl;
end

always_ff @(posedge clk) begin
	if (reset) begin
		ir_transid_reg <= 8'b0; 
		rf_transid_reg <= 8'b0;
		load_ir_transid_reg <= 8'b0; 
		load_dmem_transid_reg <= 8'b0; 
	end else begin
		if (ir_val && ir_rdy) begin
			ir_transid_reg <= ir_transid_reg + 8'b1; 
		end

		if (load_ir_val && load_ir_rdy) begin
			load_ir_transid_reg <= load_ir_transid_reg + 8'b1; 
		end

		if (load_dmem_val && load_dmem_rdy) begin
			load_dmem_transid_reg <= load_dmem_transid_reg + 8'b1; 
		end

		if (rf_val && rf_rdy) begin
			rf_transid_reg <= rf_transid_reg + 8'b1; 
		end
	end
end

always_ff @(posedge clk) begin
	if (reset) begin
		ir_Dhl_prev <= 32'b0; 
	end else begin
		ir_Dhl_prev <= ctrl.ir_Dhl; 
	end
end

always @(posedge clk) begin
	if (reset) begin
		alu_output_reg <= 32'b0;
		dmemreq_msg_addr_Mhl <= 32'b0; 
		dmemreq_msg_addr_Whl <= 32'b0;
		rf_data_reg <= 32'b0;
		rd_reg <= 5'b0;
		rf_waddr_Whl_reg <= 5'b0;
		mem_addr_reg <= 32'b0;
		dmemreq_val_Mhl <= 1'b0;
		dmemreq_rdy_Mhl <= 1'b0;
	end

	else begin
		if (ir_val) begin
			alu_output_reg <= alu_output;
			rd_reg <= rd;
		end

		if (load_ir_val) begin
			mem_addr_reg <= mem_addr;
		end 

		if (!ctrl.stall_Xhl)  begin
			dmemreq_msg_addr_Mhl <= dpath.dmemreq_msg_addr;
		end

		if (load_dmem_val) begin
			dmemreq_msg_addr_Whl <= dmemreq_msg_addr_Mhl;
		end

		if (rf_val) begin
			rf_data_reg <= dpath.wb_mux_out_Whl;
			rf_waddr_Whl_reg <= dpath.rf_waddr_Whl;
		end
		if (ctrl.inst_val_Dhl && !ctrl.stall_Xhl) begin
			dmemreq_msg_rw_Xhl <= ctrl.cs[`RISCV_INST_MSG_MEM_REQ]; 
		end

		if (ctrl.inst_val_Xhl) begin
			dmemreq_msg_rw_Mhl <= dmemreq_msg_rw_Xhl; 
			dmemreq_val_Mhl <= ctrl.dmemreq_val_Xhl;
			dmemreq_rdy_Mhl <= ctrl.dmemreq_rdy;
		end
	end
end

// Assumptions
// Assume valid opcode
am_val_instr: assume property (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl || type_load_instr_Dhl);

// Assume that the imemreq and imemresp_val happen at the same cycle
am_imemreq_imemval_same_cycle: assume property (!imemreq_val |-> !imemresp_val);

// Assume that the data memory will eventually become ready after a request is made
am_dmemreq_val_eventually: assume property (ctrl.dmemreq_val_Xhl |-> s_eventually dmemreq_rdy);

// Assume that eventually dmem will give a valid response 
am_dmemreq_imemval_same_cycle: assume property (dmemreq_val |-> s_eventually dmemresp_val);

// Assertions
// Assert that the read ports to the register file match  rs1 and rs2 from the opcode
as_rs1_match: assert property ((type_alu_r_instr_Dhl || type_alu_i_instr_Dhl || type_load_instr_Dhl) && ctrl.inst_val_Dhl |-> (rs1 == dpath.rf_raddr0_Dhl));
as_rs2_match: assert property ((type_alu_r_instr_Dhl || type_alu_i_instr_Dhl) && ctrl.inst_val_Dhl |-> (rs2 == dpath.rf_raddr1_Dhl)); 

// Assert that rd in W stage matches rd of the decoded instruction for the same transid
as__ir_rf_trans_transid_data_integrity_rd: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response && (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl || type_load_instr_Dhl) |-> (rf_waddr_Whl_reg == ir_rf_trans_transid_data_model_rd));

endmodule