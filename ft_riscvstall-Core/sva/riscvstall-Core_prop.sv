// This property file was autogenerated by AutoSVA on 2024-04-27
// to check the behavior of the original RTL module, whose interface is described below: 


`include "../../ece475-lab2/vc/vc-MemReqMsg.v"
`include "../../ece475-lab2/vc/vc-MemRespMsg.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreCtrl.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreDpath.v"
`include "../../ece475-lab2/riscvstall/riscvstall-InstMsg.v"


module riscv_Core_prop
#(
		parameter ASSERT_INPUTS = 0)
(
		
		input         clk,
		input         reset,
		
		// Instruction Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] imemreq_msg, //output
		input                                  imemreq_val, //output
		input                                  imemreq_rdy,
		
		// Instruction Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] imemresp_msg,
		input                               imemresp_val,
		
		// Data Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] dmemreq_msg, //output
		input                                  dmemreq_val, //output
		input                                  dmemreq_rdy,
		
		// Data Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] dmemresp_msg,
		input                               dmemresp_val,
		
		// CSR Status Register Output to Host
		
		input  [31:0] csr_status //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (reset);

// Re-defined wires 
wire [7:0] ir_transid;
wire [7:0] rf_transid;
wire rf_val;
wire rf_rdy;
wire ir_val;
wire ir_rdy;
wire [32:0] ir_data;
wire [32:0] rf_data;
wire [7:0] load_ir_transid;
wire [7:0] load_dmem_transid;
wire load_ir_rdy;
wire load_ir_val;
wire load_dmem_rdy;
wire load_dmem_val;
wire load_ir_data;
wire load_dmem_data;

// Symbolics and Handshake signals
wire [7:0] symb_ir_transid;
am__symb_ir_transid_stable: assume property($stable(symb_ir_transid));
wire rf_hsk = rf_val && rf_rdy;
wire ir_hsk = ir_val && ir_rdy;
wire [7:0] symb_load_ir_transid;
am__symb_load_ir_transid_stable: assume property($stable(symb_load_ir_transid));
wire load_dmem_hsk = load_dmem_val && load_dmem_rdy;
wire load_ir_hsk = load_ir_val && load_ir_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for ir_rf_trans
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_fairness: assert property (rf_val |-> s_eventually(rf_rdy));
end else begin
	am__ir_rf_trans_fairness: assume property (rf_val |-> s_eventually(rf_rdy));
end

// Generate sampling signals and model
reg [3:0] ir_rf_trans_transid_sampled;
wire ir_rf_trans_transid_set = ir_hsk && ir_transid == symb_ir_transid;

wire ir_rf_trans_transid_response = rf_hsk && ((rf_transid == symb_ir_transid) && (symb_ir_transid != 8'b0));

always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_sampled <= '0;
	end else if (ir_rf_trans_transid_set || ir_rf_trans_transid_response ) begin
		ir_rf_trans_transid_sampled <= ir_rf_trans_transid_sampled + ir_rf_trans_transid_set - ir_rf_trans_transid_response;
	end
end
co__ir_rf_trans_transid_sampled: cover property (|ir_rf_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_transid_sample_no_overflow: assert property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end else begin
	am__ir_rf_trans_transid_sample_no_overflow: assume property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__ir_rf_trans_transid_hsk_or_drop: assert property (ir_val |-> s_eventually(!ir_val || ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__ir_rf_trans_transid_eventual_response: assert property (|ir_rf_trans_transid_sampled && (symb_ir_transid != 32'b0) |-> s_eventually(rf_val && (rf_transid == symb_ir_transid) ));
as__ir_rf_trans_transid_was_a_request: assert property (ir_rf_trans_transid_response |-> ir_rf_trans_transid_set || ir_rf_trans_transid_sampled);


// Modeling data integrity for ir_rf_trans_transid
reg [32:0] ir_rf_trans_transid_data_model;
reg [32:0] ir_rf_trans_transid_data_model_rd;
always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_data_model <= '0;
		ir_rf_trans_transid_data_model_rd <= 'b0; 
	end else if (ir_rf_trans_transid_set) begin
		ir_rf_trans_transid_data_model <= ir_data;
		ir_rf_trans_transid_data_model_rd <= rd_reg;
	end
end

as__ir_rf_trans_transid_data_unique: assert property (|ir_rf_trans_transid_sampled  && (symb_ir_transid != 32'b0) |-> !ir_rf_trans_transid_set);
as__ir_rf_trans_transid_data_integrity: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response |-> (rf_data == ir_rf_trans_transid_data_model));

// Modeling incoming request for load_ir_dmem_trans
if (ASSERT_INPUTS) begin
	as__load_ir_dmem_trans_fairness: assert property (load_dmem_val |-> s_eventually(load_dmem_rdy));
end else begin
	am__load_ir_dmem_trans_fairness: assume property (load_dmem_val |-> s_eventually(load_dmem_rdy));
end

// Generate sampling signals and model
reg [3:0] load_ir_dmem_trans_transid_sampled;
wire load_ir_dmem_trans_transid_set = load_ir_hsk && load_ir_transid == symb_load_ir_transid;
wire load_ir_dmem_trans_transid_response = load_dmem_hsk && load_dmem_transid == symb_load_ir_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		load_ir_dmem_trans_transid_sampled <= '0;
	end else if (load_ir_dmem_trans_transid_set || load_ir_dmem_trans_transid_response ) begin
		load_ir_dmem_trans_transid_sampled <= load_ir_dmem_trans_transid_sampled + load_ir_dmem_trans_transid_set - load_ir_dmem_trans_transid_response;
	end
end
co__load_ir_dmem_trans_transid_sampled: cover property (|load_ir_dmem_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__load_ir_dmem_trans_transid_sample_no_overflow: assert property (load_ir_dmem_trans_transid_sampled != '1 || !load_ir_dmem_trans_transid_set);
end else begin
	am__load_ir_dmem_trans_transid_sample_no_overflow: assume property (load_ir_dmem_trans_transid_sampled != '1 || !load_ir_dmem_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__load_ir_dmem_trans_transid_hsk_or_drop: assert property (load_ir_val |-> s_eventually(!load_ir_val || load_ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__load_ir_dmem_trans_transid_eventual_response: assert property (|load_ir_dmem_trans_transid_sampled && (symb_load_ir_transid != 32'b0) |-> s_eventually(load_dmem_val && (load_dmem_transid == symb_load_ir_transid) ));
as__load_ir_dmem_trans_transid_was_a_request: assert property (load_ir_dmem_trans_transid_response |-> load_ir_dmem_trans_transid_set || load_ir_dmem_trans_transid_sampled);


// Modeling data integrity for load_ir_dmem_trans_transid
reg [0:0] load_ir_dmem_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		load_ir_dmem_trans_transid_data_model <= '0;
	end else if (load_ir_dmem_trans_transid_set) begin
		load_ir_dmem_trans_transid_data_model <= load_ir_data;
	end
end

as__load_ir_dmem_trans_transid_data_unique: assert property (|load_ir_dmem_trans_transid_sampled  && (symb_load_ir_transid != 32'b0) |-> !load_ir_dmem_trans_transid_set);
as__load_ir_dmem_trans_transid_data_integrity: assert property (|load_ir_dmem_trans_transid_sampled && load_ir_dmem_trans_transid_response |-> (load_dmem_data == load_ir_dmem_trans_transid_data_model));

assign load_ir_transid = load_ir_transid_reg;
assign ir_data = alu_output_reg;
assign ir_rdy = !stall_Dhl_reg;
assign ir_val = ctrl.inst_val_Dhl && (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl);
assign rf_data = rf_data_reg;
assign rf_transid = rf_transid_reg;
assign load_ir_data = mem_addr_reg;
assign load_dmem_transid = load_dmem_transid_reg;
assign load_dmem_data = dmemreq_msg_addr_reg;
assign load_dmem_rdy = dmemreq_rdy;
assign rf_rdy = 1'b1;
assign load_ir_val = ctrl.inst_val_Dhl && type_load_instr;
assign rf_val = ctrl.rf_wen_Whl && ctrl.inst_val_Whl && (type_alu_r_instr_Whl || type_alu_i_instr_Whl); // if it is an ALU op,
assign ir_transid = ir_transid_reg;
assign load_dmem_val = dmemreq_val && core.dmemreq_msg_rw;
// assign load_dmem_val = ctrl.inst_val_Mhl && (dmemreq_msg_rw_Mhl == 1'b1);
assign load_ir_rdy = !stall_Dhl_reg;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_rf_val: assert property(!$isunknown(rf_val));
	 as__no_x_rf_data: assert property(rf_val |-> !$isunknown(rf_data));
	 as__no_x_rf_transid: assert property(rf_val |-> !$isunknown(rf_transid));
	 as__no_x_ir_val: assert property(!$isunknown(ir_val));
	 as__no_x_ir_data: assert property(ir_val |-> !$isunknown(ir_data));
	 as__no_x_ir_transid: assert property(ir_val |-> !$isunknown(ir_transid));
	 as__no_x_load_ir_val: assert property(!$isunknown(load_ir_val));
	 as__no_x_load_ir_transid: assert property(load_ir_val |-> !$isunknown(load_ir_transid));
	 as__no_x_load_ir_data: assert property(load_ir_val |-> !$isunknown(load_ir_data));
	 as__no_x_load_dmem_val: assert property(!$isunknown(load_dmem_val));
	 as__no_x_load_dmem_data: assert property(load_dmem_val |-> !$isunknown(load_dmem_data));
	 as__no_x_load_dmem_transid: assert property(load_dmem_val |-> !$isunknown(load_dmem_transid));
`endif

//====DESIGNER-ADDED-SVA====//
// Register definitons
reg [7:0] ir_transid_reg;
reg [7:0] rf_transid_reg; 
reg [31:0] rf_data_reg;
reg stall_Dhl_reg;
reg [4:0] rd_reg;
reg [4:0] rf_waddr_Whl_reg;
reg [31:0] alu_output; 
reg [31:0] alu_output_reg;
reg [31:0] ir_Dhl_prev;
reg [31:0] ir_Xhl;
reg [31:0] ir_Mhl;
reg [31:0] ir_Whl;

// Unsigned wires for muldiv
reg [31:0] unsigned_a;
reg [31:0] unsigned_b;
reg [31:0] unsigned_res;

// Load Regs 
reg dmemreq_msg_rw_Mhl;
reg [31:0] mem_addr_reg;
reg [31:0] dmemreq_msg_addr_reg;
reg [7:0] load_ir_transid_reg;
reg [7:0] load_dmem_transid_reg; 
reg [31:0] mem_addr; 

// Wire definitions
wire [31:0] rs1_data = dpath.rf_rdata0_Dhl;
wire [31:0] rs2_data = dpath.rf_rdata1_Dhl;

// Parse the opcode
wire [31:25] func7_t = ctrl.ir_Dhl[31:25]; 
wire [31:0] i_immediate_12_bits = {{20{ctrl.ir_Dhl[31]}}, ctrl.ir_Dhl[31:20]};
wire [24:20] i_immediate_5_bits = ctrl.ir_Dhl[24:20];
wire [24:20] rs2 = ctrl.ir_Dhl[24:20]; 
wire [19:15] rs1 = ctrl.ir_Dhl[19:15]; 
wire [14:12] rtype_funct3_t = ctrl.ir_Dhl[14:12]; 
wire [11:7] rd = ctrl.ir_Dhl[11:7]; 
wire [6:0] opcode_t = ctrl.ir_Dhl[6:0];

// Determine type of instruction
wire type_alu_r_instr_Dhl = ((ctrl.ir_Dhl  == `RISCV_INST_MSG_ADD) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_SUB) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_SLL) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_SLT) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTU) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_XOR) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_SRL) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_SRA) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_OR) ||
						(ctrl.ir_Dhl  == `RISCV_INST_MSG_AND)); //|| 
						//(ctrl.ir_Dhl  == `RISCV_INST_MSG_MUL) ||
						//(ctrl.ir_Dhl  == `RISCV_INST_MSG_DIV) || 
						//(ctrl.ir_Dhl  == `RISCV_INST_MSG_DIVU) || 
						//(ctrl.ir_Dhl  == `RISCV_INST_MSG_REM)) ||
						//(ctrl.ir_Dhl  == `RISCV_INST_MSG_REMU));

wire type_alu_r_instr_Whl = ((ir_Whl  == `RISCV_INST_MSG_ADD) ||
						(ir_Whl  == `RISCV_INST_MSG_SUB) ||
						(ir_Whl  == `RISCV_INST_MSG_SLL) ||
						(ir_Whl  == `RISCV_INST_MSG_SLT) ||
						(ir_Whl  == `RISCV_INST_MSG_SLTU) ||
						(ir_Whl  == `RISCV_INST_MSG_XOR) ||
						(ir_Whl  == `RISCV_INST_MSG_SRL) ||
						(ir_Whl  == `RISCV_INST_MSG_SRA) ||
						(ir_Whl  == `RISCV_INST_MSG_OR) ||
						(ir_Whl  == `RISCV_INST_MSG_AND)); //|| 
						//(ir_Whl  == `RISCV_INST_MSG_MUL) ||
						//(ir_Whl  == `RISCV_INST_MSG_DIV) || 
						//(ir_Whl  == `RISCV_INST_MSG_DIVU) || 
						//(ir_Whl  == `RISCV_INST_MSG_REM)) ||
						//(ir_Whl  == `RISCV_INST_MSG_REMU));

wire type_alu_i_instr_Dhl = ((ctrl.ir_Dhl  == `RISCV_INST_MSG_ADDI) ||    
						 (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTI) ||    
						 (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTIU) ||  
						 (ctrl.ir_Dhl  == `RISCV_INST_MSG_XORI)|| 
						 (ctrl.ir_Dhl  == `RISCV_INST_MSG_ORI) ||   
						 (ctrl.ir_Dhl  == `RISCV_INST_MSG_ANDI) ||    
						 (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLLI) || 
						 (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRLI) ||  
						 (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRAI) );

wire type_alu_i_instr_Whl = ((ir_Whl  == `RISCV_INST_MSG_ADDI) ||    
						 (ir_Whl  == `RISCV_INST_MSG_SLTI) ||    
						 (ir_Whl  == `RISCV_INST_MSG_SLTIU) ||  
						 (ir_Whl  == `RISCV_INST_MSG_XORI)|| 
						 (ir_Whl  == `RISCV_INST_MSG_ORI) ||   
						 (ir_Whl  == `RISCV_INST_MSG_ANDI) ||    
						 (ir_Whl  == `RISCV_INST_MSG_SLLI) || 
						 (ir_Whl  == `RISCV_INST_MSG_SRLI) ||  
						 (ir_Whl  == `RISCV_INST_MSG_SRAI) );

wire type_load_instr = ((ctrl.ir_Dhl  == `RISCV_INST_MSG_LW));
wire type_load_instr_wb = ((ir_Whl  == `RISCV_INST_MSG_LW));

// Calculate expected ALU output
always_comb begin
	alu_output = 32'bx;
	unsigned_a = (rs1_data[31] ?  ~rs1_data + 1'b1 : rs1_data); 
	unsigned_b = (rs2_data[31] ?  ~rs2_data + 1'b1 : rs2_data);
	mem_addr = 32'bx; 
	// ALU R type instructions
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_ADD) begin
		alu_output = rs1_data + rs2_data;
	end 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SUB) begin
		alu_output = rs1_data - rs2_data;
	end 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLL) begin
		alu_output = rs1_data << rs2_data[4:0];
	end 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLT) begin 
		alu_output = ($signed(rs1_data) < $signed(rs2_data));
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTU) begin
		alu_output = ($unsigned(rs1_data) < $unsigned(rs2_data));
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_XOR) begin
		alu_output = (rs1_data ^ rs2_data); 
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRL) begin
		alu_output = rs1_data >> rs2_data[4:0];
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRA) begin
		alu_output =  $signed(rs1_data) >>> rs2_data[4:0];
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_OR) begin
		alu_output = (rs1_data | rs2_data);
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_AND) begin
		alu_output = (rs1_data & rs2_data);
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_MUL) begin
		unsigned_res = unsigned_a * unsigned_b;
		alu_output = (rs1_data[31] ^ rs2_data[31]) ? ~unsigned_res + 32'b1 : unsigned_res; 
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_DIV) begin
		unsigned_res = unsigned_a / unsigned_b;
		alu_output = (rs1_data[31] ^ rs2_data[31]) ? ~unsigned_res + 32'b1 : unsigned_res; 
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_DIVU) begin
		unsigned_res = unsigned_a / unsigned_b;
		alu_output = unsigned_res; 
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_REM) begin
		unsigned_res = unsigned_a % unsigned_b;
		alu_output = (rs1_data[31] ^ rs2_data[31]) ? ~unsigned_res + 32'b1 : unsigned_res;
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_REMU) begin
		unsigned_res = unsigned_a % unsigned_b;
		alu_output = unsigned_res;
	end

	// ALU I type instructions
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_ADDI) begin
		alu_output = rs1_data + i_immediate_12_bits;
	end 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLLI) begin
		alu_output = rs1_data << i_immediate_5_bits;
	end 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTI) begin 
		alu_output = ($signed(rs1_data) < $signed(i_immediate_12_bits));
	end

	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTIU) begin
		alu_output = ($unsigned(rs1_data) < $unsigned(i_immediate_12_bits));
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_XORI) begin
		alu_output = (rs1_data ^ $signed(i_immediate_12_bits)); 
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRLI) begin
		alu_output = rs1_data >> i_immediate_5_bits;
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRAI) begin
		alu_output =  $signed(rs1_data) >>> i_immediate_5_bits;
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_ORI) begin
		alu_output = (rs1_data | $signed(i_immediate_12_bits));
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_ANDI) begin
		alu_output = (rs1_data & $signed(i_immediate_12_bits));
	end

	// Calculate the load address
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_LW) begin
		mem_addr = (rs1_data + $signed(i_immediate_12_bits));
	end
end 

// Implement flip-flops needed for data integrity checks
always_ff @(posedge clk) begin
	stall_Dhl_reg <= ctrl.stall_Dhl; 
end

always_ff @(posedge clk) begin
	if (reset) begin
		ir_transid_reg <= 8'b0; 
		rf_transid_reg <= 8'b0;
		load_ir_transid_reg <= 8'b0; 
		load_dmem_transid_reg <= 8'b0; 
	end else begin
		if (ir_val && ir_rdy) begin
			ir_transid_reg <= ir_transid_reg + 8'b1; 
		end

		if (load_ir_val && load_ir_rdy) begin
			load_ir_transid_reg <= load_ir_transid_reg + 8'b1; 
		end

		if (load_dmem_val && load_dmem_rdy) begin
			load_dmem_transid_reg <= load_dmem_transid_reg + 8'b1; 
		end

		if (rf_val && rf_rdy) begin
			rf_transid_reg <= rf_transid_reg + 8'b1; 
		end
	end
end

always_ff @(posedge clk) begin
	if (reset) begin
		ir_Dhl_prev <= 32'b0; 
	end else begin
		ir_Dhl_prev <= ctrl.ir_Dhl; 
	end
end

always @(posedge clk) begin
	if (reset) begin
		alu_output_reg <= 32'b0;
		rf_data_reg <= 32'b0;
		rd_reg <= 5'b0;
		rf_waddr_Whl_reg <= 5'b0;
		mem_addr_reg <= 32'b0;
	end
	else begin
		if (ctrl.inst_val_Dhl && (type_alu_i_instr_Dhl || type_alu_r_instr_Dhl)) begin
			alu_output_reg <= alu_output;
			rd_reg <= rd;
			mem_addr_reg <= mem_addr;
		end
		if (ctrl.inst_val_Whl && ctrl.rf_wen_Whl) begin
			rf_data_reg <= dpath.wb_mux_out_Whl;
			rf_waddr_Whl_reg <= dpath.rf_waddr_Whl;
		end

		if (ctrl.inst_val_Xhl) begin
			dmemreq_msg_rw_Mhl <= ctrl.dmemreq_msg_rw_Xhl; 
		end
	end
end

// keep track our the instructions ourselves
always @(posedge clk) begin
	if (!ctrl.stall_Dhl) 
		ir_Xhl <= ctrl.ir_Dhl; 
	if (!ctrl.stall_Xhl)
		ir_Mhl <= ir_Xhl;
	if (!ctrl.stall_Mhl) 
		ir_Whl <= ir_Mhl; 
end

// Assumptions
// Assume valid opcode
as_val_instr: assume property (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl); // || type_load_instr 

// Assume that the imemreq and imemresp_val happen at the same cycle
as_imemreq_imemval_same_cycle: assume property (!imemreq_val |-> !imemresp_val);

// Assume that the 
as_dmemreq_val_eventually: assume property (ctrl.dmemreq_val_Xhl |-> s_eventually dmemreq_rdy);

// Assertions
// Assert that the read ports to the register file match  rs1 and rs2 from the opcode
as_rs1_match: assert property ((type_alu_r_instr_Dhl || type_alu_i_instr_Dhl || type_load_instr) && ctrl.inst_val_Dhl |-> (rs1 == dpath.rf_raddr0_Dhl)); 
as_rs2_match: assert property (type_alu_r_instr_Dhl && ctrl.inst_val_Dhl |-> (rs2 == dpath.rf_raddr1_Dhl)); 

// Assert that rd in W stage matches rd of the decoded instruction for the same transid
//|| type_load_instr)
as__ir_rf_trans_transid_data_integrity_rd: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response && (type_alu_r_instr_Dhl || type_alu_i_instr_Dhl) |-> (rf_waddr_Whl_reg == ir_rf_trans_transid_data_model_rd));

endmodule