// This property file was autogenerated by AutoSVA on 2024-04-25
// to check the behavior of the original RTL module, whose interface is described below: 


`include "../../ece475-lab2/vc/vc-MemReqMsg.v"
`include "../../ece475-lab2/vc/vc-MemRespMsg.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreCtrl.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreDpath.v"
`include "../../ece475-lab2/riscvstall/riscvstall-InstMsg.v"

//[4:0] ir_data = dpath.inst_rd_Dhl;
//[4:0] rf_data = dpath.rf_waddr_Whl;
module riscv_Core_prop
#(
		parameter ASSERT_INPUTS = 0)
(
		
		input         clk,
		input         reset,
		
		// Instruction Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] imemreq_msg, //output
		input                                  imemreq_val, //output
		input                                  imemreq_rdy,
		
		// Instruction Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] imemresp_msg,
		input                               imemresp_val,
		
		// Data Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] dmemreq_msg, //output
		input                                  dmemreq_val, //output
		input                                  dmemreq_rdy,
		
		// Data Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] dmemresp_msg,
		input                               dmemresp_val,
		
		// CSR Status Register Output to Host
		
		input  [31:0] csr_status //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (reset);

// Re-defined wires 
wire [7:0] ir_transid;
wire [7:0] rf_transid;
wire rf_val;
wire rf_rdy;
wire ir_val;
wire ir_rdy;
wire [32:0] ir_data;
wire [32:0] rf_data;

// Symbolics and Handshake signals
wire [7:0] symb_ir_transid;
am__symb_ir_transid_stable: assume property($stable(symb_ir_transid));
wire rf_hsk = rf_val && rf_rdy;
wire ir_hsk = ir_val && ir_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for ir_rf_trans
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_fairness: assert property (rf_val |-> s_eventually(rf_rdy));
end else begin
	am__ir_rf_trans_fairness: assume property (rf_val |-> s_eventually(rf_rdy));
end

// Generate sampling signals and model
reg [3:0] ir_rf_trans_transid_sampled;
wire ir_rf_trans_transid_set = ir_hsk && ir_transid == symb_ir_transid;
wire ir_rf_trans_transid_response = rf_hsk && rf_transid == symb_ir_transid;

always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_sampled <= '0;
	end else if (ir_rf_trans_transid_set || ir_rf_trans_transid_response ) begin
		ir_rf_trans_transid_sampled <= ir_rf_trans_transid_sampled + ir_rf_trans_transid_set - ir_rf_trans_transid_response;
	end
end
co__ir_rf_trans_transid_sampled: cover property (|ir_rf_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_transid_sample_no_overflow: assert property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end else begin
	am__ir_rf_trans_transid_sample_no_overflow: assume property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__ir_rf_trans_transid_hsk_or_drop: assert property (ir_val |-> s_eventually(!ir_val || ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__ir_rf_trans_transid_eventual_response: assert property (|ir_rf_trans_transid_sampled |-> s_eventually(rf_val && (rf_transid == symb_ir_transid) ));
as__ir_rf_trans_transid_was_a_request: assert property (ir_rf_trans_transid_response |-> ir_rf_trans_transid_set || ir_rf_trans_transid_sampled);


// Modeling data integrity for ir_rf_trans_transid
reg [32:0] ir_rf_trans_transid_data_model;
always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_data_model <= '0;
	end else if (ir_rf_trans_transid_set) begin
		ir_rf_trans_transid_data_model <= ir_data;
	end
end

as__ir_rf_trans_transid_data_unique: assert property (|ir_rf_trans_transid_sampled |-> !ir_rf_trans_transid_set);
as__ir_rf_trans_transid_data_integrity: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response |-> (rf_data == ir_rf_trans_transid_data_model));

assign ir_data = alu_output;
assign ir_rdy = !stall_Dhl_reg; //(ir_Dhl_prev != 32'b0) || ((ir_Dhl_prev != ctrl.ir_Dhl) && stall_Dhl_reg);
assign ir_val = ctrl.inst_val_Dhl;
assign rf_data = dpath.wb_mux_out_Whl;
assign rf_transid = rf_transid_reg;
assign rf_rdy = 1'b1;
assign rf_val = dpath.rf_wen_Whl && ctrl.inst_val_Whl;
assign ir_transid = ir_transid_reg;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_rf_val: assert property(!$isunknown(rf_val));
	 as__no_x_rf_data: assert property(rf_val |-> !$isunknown(rf_data));
	 as__no_x_rf_transid: assert property(rf_val |-> !$isunknown(rf_transid));
	 as__no_x_ir_val: assert property(!$isunknown(ir_val));
	 as__no_x_ir_transid: assert property(ir_val |-> !$isunknown(ir_transid));
	 as__no_x_ir_data: assert property(ir_val |-> !$isunknown(ir_data));
`endif

//====DESIGNER-ADDED-SVA====//
reg [7:0] ir_transid_reg;
reg [7:0] rf_transid_reg; 
reg stall_Dhl_reg; 

always_ff @(posedge clk) begin
	stall_Dhl_reg <= ctrl.stall_Dhl; 
end
always_ff @(posedge clk) begin
	if (reset) begin
		ir_transid_reg <= 8'b0; 
		rf_transid_reg <= 8'b0;
	end else begin
		if (ir_val && ir_rdy) begin
			ir_transid_reg <= ir_transid_reg + 8'b1; 
		end

		if (rf_val) begin
			rf_transid_reg <= rf_transid_reg + 8'b1; 
		end
	end
end

reg [31:0] ir_Dhl_prev;
always_ff @(posedge clk) begin
	if (reset) begin
		ir_Dhl_prev <= 32'b0; 
	end else begin
		ir_Dhl_prev <= ctrl.ir_Dhl; 
	end
end

as_r_type_alu_instr: assume property ((ctrl.ir_Dhl  == `RISCV_INST_MSG_ADD) ||
									  (ctrl.ir_Dhl  == `RISCV_INST_MSG_SUB));
									//   (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLL) ||
									//   (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLT) ||
									//   (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTU) ||
									//   (ctrl.ir_Dhl  == `RISCV_INST_MSG_XOR) ||
									//   (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRL) ||
									//   (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRA) ||
									//   (ctrl.ir_Dhl  == `RISCV_INST_MSG_OR) ||
									//   (ctrl.ir_Dhl  == `RISCV_INST_MSG_AND) );

//verify the instruction is decoded correctly
wire [31:25] func7_t = ctrl.ir_Dhl[31:25]; 
wire [24:20] rs2 = ctrl.ir_Dhl[24:20]; 
wire [19:15] rs1 = ctrl.ir_Dhl[19:15]; 
wire [14:12] rtype_funct3_t = ctrl.ir_Dhl[14:12]; 
wire [11:7] rd = ctrl.ir_Dhl[11:7]; 
wire [6:0] opcode_t = ctrl.ir_Dhl[6:0]; 

//assert that the read ports to the register file match the rs1 and rs2 from the opcode
as_rs1_match: assert property (ctrl.inst_val_Dhl |-> (rs1 == dpath.rf_raddr0_Dhl)); 
as_rs2_match: assert property (ctrl.inst_val_Dhl |-> (rs2 == dpath.rf_raddr1_Dhl)); 
//as_rd_match: assert property (ctrl.inst_val_Dhl |-> (rd == dpath.rf_waddr_Whl)); 
wire [31:0] rs1_data = dpath.rf_rdata0_Dhl;
wire [31:0] rs2_data = dpath.rf_rdata1_Dhl;
reg [31:0] alu_output; 
reg rtype_alu_instr; 
// performs the operation that will be checked at the end
always_comb begin
	alu_output = 32'bx;
	rtype_alu_instr = 1'b0; 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_ADD) begin
		alu_output = rs1_data + rs2_data;
		rtype_alu_instr = 1'b1; 
	end 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SUB) begin
		alu_output = rs1_data - rs2_data;
		rtype_alu_instr = 1'b1; 
	end 
	// if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLL) begin
	// 	alu_output = rs1_data << rs2_data;
	// 	rtype_alu_instr = 1'b1; 
	// end 
	// if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLT) begin 
	// 	alu_output = ($signed(rs1_data) < $signed(rs2_data));
	// 	rtype_alu_instr = 1'b1; 
	// end
	// if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTU) begin
	// 	alu_output = ($unsigned(rs1_data) < $unsigned(rs2_data));
	// 	rtype_alu_instr = 1'b1; 
	// end
	// if (ctrl.ir_Dhl  == `RISCV_INST_MSG_XOR) begin
	// 	alu_output = (rs1_data ^ rs2_data);
	// 	rtype_alu_instr = 1'b1; 
	// end
	// if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRL) begin
	// 	alu_output = rs1_data >> rs2_data;
	// 	rtype_alu_instr = 1'b1; 
	// end
	// if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRA) begin
	// 	alu_output =  $signed(rs1_data) >>> rs2_data;
	// 	rtype_alu_instr = 1'b1; 
	// end
	// if (ctrl.ir_Dhl  == `RISCV_INST_MSG_OR) begin
	// 	alu_output = (rs1_data || rs2_data);
	// 	rtype_alu_instr = 1'b1; 
	// end
	// if (ctrl.ir_Dhl  == `RISCV_INST_MSG_AND) begin
	// 	alu_output = (rs1_data && rs2_data);
	// 	rtype_alu_instr = 1'b1; 
	// end
end 

// assert the alu_output is correct
//as__ir_rf_trans_transid_data_unique: assert property (|imem_rf_trans_transid_sampled |-> !imem_rf_trans_transid_set);

//as__ir_rf_trans_transid_data_integrity: assert property (|imem_rf_trans_transid_sampled && imem_rf_trans_transid_response |-> (alu_output == dpath.wb_mux_out_Whl));

// as_alu_output_matches: assert property ((ctrl.inst_val_Whl && ctrl.rf_wen_Whl && rtype_alu_instr) |-> (alu_output == dpath.wb_mux_out_Whl));
// assume that the imemreq and imemreq_val are the same cycle
as_imemreq_imemval_same_cycle: assume property (!imemreq_val |-> !imemresp_val);
endmodule