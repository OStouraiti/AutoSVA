// This property file was autogenerated by AutoSVA on 2024-04-25
// to check the behavior of the original RTL module, whose interface is described below: 


`include "../../ece475-lab2/vc/vc-MemReqMsg.v"
`include "../../ece475-lab2/vc/vc-MemRespMsg.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreCtrl.v"
`include "../../ece475-lab2/riscvstall/riscvstall-CoreDpath.v"
`include "../../ece475-lab2/riscvstall/riscvstall-InstMsg.v"
`include "../../ece475-lab2/riscvstall/riscvstall-Instructions.v"

module riscv_Core_prop
#(
		parameter ASSERT_INPUTS = 0)
(
		
		input         clk,
		input         reset,
		
		// Instruction Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] imemreq_msg, //output
		input                                  imemreq_val, //output
		input                                  imemreq_rdy,
		
		// Instruction Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] imemresp_msg,
		input                               imemresp_val,
		
		// Data Memory Request Port
		
		input  [`VC_MEM_REQ_MSG_SZ(32,32)-1:0] dmemreq_msg, //output
		input                                  dmemreq_val, //output
		input                                  dmemreq_rdy,
		
		// Data Memory Response Port
		
		input [`VC_MEM_RESP_MSG_SZ(32)-1:0] dmemresp_msg,
		input                               dmemresp_val,
		
		// CSR Status Register Output to Host
		
		input  [31:0] csr_status //output
	);

//==============================================================================
// Local Parameters
//==============================================================================

genvar j;
default clocking cb @(posedge clk);
endclocking
default disable iff (reset);

// Re-defined wires 
wire [7:0] ir_transid;
wire [7:0] rf_transid;
wire rf_val;
wire rf_rdy;
wire ir_val;
wire ir_rdy;
wire [32:0] ir_data;
wire [32:0] rf_data;

// Symbolics and Handshake signals
wire [7:0] symb_ir_transid;
am__symb_ir_transid_stable: assume property($stable(symb_ir_transid));
wire rf_hsk = rf_val && rf_rdy;
wire ir_hsk = ir_val && ir_rdy;

//==============================================================================
// Modeling
//==============================================================================

// Modeling incoming request for ir_rf_trans
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_fairness: assert property (rf_val |-> s_eventually(rf_rdy));
end else begin
	am__ir_rf_trans_fairness: assume property (rf_val |-> s_eventually(rf_rdy));
end

// Generate sampling signals and model
reg [3:0] ir_rf_trans_transid_sampled;
wire ir_rf_trans_transid_set = ir_hsk && ir_transid == symb_ir_transid;
wire ir_rf_trans_transid_response = rf_hsk && ((rf_transid == symb_ir_transid) && (symb_ir_transid != 8'b0));

always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_sampled <= '0;
	end else if (ir_rf_trans_transid_set || ir_rf_trans_transid_response ) begin
		ir_rf_trans_transid_sampled <= ir_rf_trans_transid_sampled + ir_rf_trans_transid_set - ir_rf_trans_transid_response;
	end
end
co__ir_rf_trans_transid_sampled: cover property (|ir_rf_trans_transid_sampled);
if (ASSERT_INPUTS) begin
	as__ir_rf_trans_transid_sample_no_overflow: assert property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end else begin
	am__ir_rf_trans_transid_sample_no_overflow: assume property (ir_rf_trans_transid_sampled != '1 || !ir_rf_trans_transid_set);
end


// Assert that if valid eventually ready or dropped valid
as__ir_rf_trans_transid_hsk_or_drop: assert property (ir_val |-> s_eventually(!ir_val || ir_rdy));
// Assert that every request has a response and that every reponse has a request
as__ir_rf_trans_transid_eventual_response: assert property (|ir_rf_trans_transid_sampled  && (symb_ir_transid != 32'b0)|-> s_eventually(rf_val && (rf_transid == symb_ir_transid)) );
as__ir_rf_trans_transid_was_a_request: assert property (ir_rf_trans_transid_response |-> ir_rf_trans_transid_set || ir_rf_trans_transid_sampled);


// Modeling data integrity for ir_rf_trans_transid
reg [32:0] ir_rf_trans_transid_data_model;
reg [32:0] ir_rf_trans_transid_data_model_rd;
always_ff @(posedge clk) begin
	if(reset) begin
		ir_rf_trans_transid_data_model <= '0;
		ir_rf_trans_transid_data_model_rd <= '0;
	end else if (ir_rf_trans_transid_set) begin
		ir_rf_trans_transid_data_model <= ir_data;
		ir_rf_trans_transid_data_model_rd <= rd_reg;
	end
end

as__ir_rf_trans_transid_data_unique: assert property (|ir_rf_trans_transid_sampled && (symb_ir_transid != 32'b0) |-> !ir_rf_trans_transid_set);
as__ir_rf_trans_transid_data_integrity: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response |-> (rf_data == ir_rf_trans_transid_data_model));

assign ir_data = alu_output_reg;
assign ir_rdy = !stall_Dhl_reg; 
assign ir_val = ctrl.inst_val_Dhl && (type_alu_r_instr_Dhl);
assign rf_data = rf_data_reg;
assign rf_transid = rf_transid_reg;
assign rf_rdy = 1'b1;
assign rf_val = dpath.rf_wen_Whl && ctrl.inst_val_Whl && (type_alu_r_instr_Whl);
assign ir_transid = ir_transid_reg;

//X PROPAGATION ASSERTIONS
`ifdef XPROP
	 as__no_x_rf_val: assert property(!$isunknown(rf_val));
	 as__no_x_rf_data: assert property(rf_val |-> !$isunknown(rf_data));
	 as__no_x_rf_transid: assert property(rf_val |-> !$isunknown(rf_transid));
	 as__no_x_ir_val: assert property(!$isunknown(ir_val));
	 as__no_x_ir_transid: assert property(ir_val |-> !$isunknown(ir_transid));
	 as__no_x_ir_data: assert property(ir_val |-> !$isunknown(ir_data));
`endif

//====DESIGNER-ADDED-SVA====//
// Type of instruction wires
wire type_add_instr_Dhl;
wire type_sub_instr_Dhl;
wire type_sll_instr_Dhl;
wire type_slt_instr_Dhl;
wire type_sltu_instr_Dhl;
wire type_xor_instr_Dhl;
wire type_srl_instr_Dhl;
wire type_sra_instr_Dhl;
wire type_or_instr_Dhl;
wire type_and_instr_Dhl;

wire type_add_instr_Whl;
wire type_sub_instr_Whl;
wire type_sll_instr_Whl;
wire type_slt_instr_Whl;
wire type_sltu_instr_Whl;
wire type_xor_instr_Whl;
wire type_srl_instr_Whl;
wire type_sra_instr_Whl;
wire type_or_instr_Whl;
wire type_and_instr_Whl;

// Register definitons
reg [7:0] ir_transid_reg;
reg [7:0] rf_transid_reg; 
reg [31:0] rf_data_reg;
reg stall_Dhl_reg;
reg [4:0] rd_reg;
reg [4:0] rf_waddr_Whl_reg;
reg [31:0] alu_output; 
reg [31:0] alu_output_reg;
reg [31:0] ir_Dhl_prev;

// Wire definitions
wire [31:0] rs1_data = dpath.rf_rdata0_Dhl;
wire [31:0] rs2_data = dpath.rf_rdata1_Dhl;

// Parse the opcode
wire [31:25] func7_t = ctrl.ir_Dhl[31:25]; 
wire [31:0] i_immediate_12_bits = {{20{ctrl.ir_Dhl[31]}}, ctrl.ir_Dhl[31:20]};
wire [24:20] i_immediate_5_bits = ctrl.ir_Dhl[24:20];
wire [24:20] rs2 = ctrl.ir_Dhl[24:20]; 
wire [19:15] rs1 = ctrl.ir_Dhl[19:15]; 
wire [14:12] rtype_funct3_t = ctrl.ir_Dhl[14:12]; 
wire [11:7] rd = ctrl.ir_Dhl[11:7]; 
wire [6:0] opcode_t = ctrl.ir_Dhl[6:0];

// Parse the instruction in the D stage
riscv_Instructions instructions_decode
(
	.instr(ctrl.ir_Dhl),
	.type_add_instr(type_add_instr_Dhl),
    .type_sub_instr(type_sub_instr_Dhl),
    .type_sll_instr(type_sll_instr_Dhl),
    .type_slt_instr(type_slt_instr_Dhl),
    .type_sltu_instr(type_sltu_instr_Dhl),
    .type_xor_instr(type_xor_instr_Dhl),
    .type_srl_instr(type_srl_instr_Dhl),
    .type_sra_instr(type_sra_instr_Dhl),
    .type_or_instr(type_or_instr_Dhl),
    .type_and_instr(type_and_instr_Dhl)
); 

// Parse the instruction in the W stage
riscv_Instructions instructions_writeback
(
	.instr(ctrl.ir_Whl),
	.type_add_instr(type_add_instr_Whl),
    .type_sub_instr(type_sub_instr_Whl),
    .type_sll_instr(type_sll_instr_Whl),
    .type_slt_instr(type_slt_instr_Whl),
    .type_sltu_instr(type_sltu_instr_Whl),
    .type_xor_instr(type_xor_instr_Whl),
    .type_srl_instr(type_srl_instr_Whl),
    .type_sra_instr(type_sra_instr_Whl),
    .type_or_instr(type_or_instr_Whl),
    .type_and_instr(type_and_instr_Whl)
);

wire type_alu_r_instr_Dhl = type_add_instr_Dhl || 
							type_sub_instr_Dhl || 
							type_sll_instr_Dhl || 
							type_slt_instr_Dhl ||
							type_sltu_instr_Dhl ||
							type_xor_instr_Dhl ||
							type_srl_instr_Dhl ||
							type_sra_instr_Dhl ||
							type_or_instr_Dhl ||
							type_and_instr_Dhl;

wire type_alu_r_instr_Whl = type_add_instr_Whl || 
							type_sub_instr_Whl || 
							type_sll_instr_Whl || 
							type_slt_instr_Whl ||
							type_sltu_instr_Whl ||
							type_xor_instr_Whl ||
							type_srl_instr_Whl ||
							type_sra_instr_Whl ||
							type_or_instr_Whl ||
							type_and_instr_Whl;

// Calculate expected ALU output
always_comb begin
	alu_output = 32'bx;
	// ALU R type instructions
	if (type_add_instr_Dhl) begin
		alu_output = rs1_data + rs2_data;
	end 
	if (type_sub_instr_Dhl) begin
		alu_output = rs1_data - rs2_data;
	end 
	if (type_sll_instr_Dhl) begin
		alu_output = rs1_data << rs2_data[4:0];
	end 
	if (type_slt_instr_Dhl) begin 
		alu_output = ($signed(rs1_data) < $signed(rs2_data));
	end
	if (type_sltu_instr_Dhl) begin
		alu_output = ($unsigned(rs1_data) < $unsigned(rs2_data));
	end
	if (type_xor_instr_Dhl) begin
		alu_output = (rs1_data ^ rs2_data); 
	end
	if (type_srl_instr_Dhl) begin
		alu_output = rs1_data >> rs2_data[4:0];
	end
	if (type_sra_instr_Dhl) begin
		alu_output =  $signed(rs1_data) >>> rs2_data[4:0];
	end
	if (type_or_instr_Dhl) begin
		alu_output = (rs1_data | rs2_data);
	end
	if (type_and_instr_Dhl) begin
		alu_output = (rs1_data & rs2_data);
	end

	// ALU I type instructions
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_ADDI) begin
		alu_output = rs1_data + i_immediate_12_bits;
	end 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLLI) begin
		alu_output = rs1_data << i_immediate_5_bits;
	end 
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTI) begin 
		alu_output = ($signed(rs1_data) < $signed(i_immediate_12_bits));
	end

	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SLTIU) begin
		alu_output = ($unsigned(rs1_data) < $unsigned(i_immediate_12_bits));
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_XORI) begin
		alu_output = (rs1_data ^ $signed(i_immediate_12_bits)); 
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRLI) begin
		alu_output = rs1_data >> i_immediate_5_bits;
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_SRAI) begin
		alu_output =  $signed(rs1_data) >>> i_immediate_5_bits;
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_ORI) begin
		alu_output = (rs1_data | $signed(i_immediate_12_bits));
	end
	if (ctrl.ir_Dhl  == `RISCV_INST_MSG_ANDI) begin
		alu_output = (rs1_data & $signed(i_immediate_12_bits));
	end
end 

// Implement flip-flops needed for data integrity checks
always_ff @(posedge clk) begin
	stall_Dhl_reg <= ctrl.stall_Dhl; 
end
always_ff @(posedge clk) begin
	if (reset) begin
		ir_transid_reg <= 8'b0; 
		rf_transid_reg <= 8'b0;
	end else begin
		if (ir_val && ir_rdy) begin
			ir_transid_reg <= ir_transid_reg + 8'b1; 
		end

		if (rf_val) begin
			rf_transid_reg <= rf_transid_reg + 8'b1; 
		end
	end
end

always_ff @(posedge clk) begin
	if (reset) begin
		ir_Dhl_prev <= 32'b0; 
	end else begin
		ir_Dhl_prev <= ctrl.ir_Dhl; 
	end
end

always @(posedge clk) begin
	if (reset) begin
		alu_output_reg <= 32'b0;
		rf_data_reg <= 32'b0;
		rd_reg <= 5'b0;
		rf_waddr_Whl_reg <= 5'b0;
	end
	else begin
		if (ctrl.inst_val_Dhl) begin
			alu_output_reg <= alu_output;
			rd_reg <= rd;
		end
		if (ctrl.inst_val_Whl && ctrl.rf_wen_Whl) begin
			rf_data_reg <= dpath.wb_mux_out_Whl;
			rf_waddr_Whl_reg <= dpath.rf_waddr_Whl;
		end
	end
end


// Assumptions
// Assume valid opcode
as_val_instr: assume property (type_alu_r_instr_Dhl);

// Assume that the imemreq and imemreq_val happen at the same cycle
as_imemreq_imemval_same_cycle: assume property (!imemreq_val |-> !imemresp_val);


// Assertions
// Assert that the read ports to the register file match  rs1 and rs2 from the opcode
// as_rs1_match: assert property (type_alu_r_instr_Dhl && ctrl.inst_val_Dhl |-> (rs1 == dpath.rf_raddr0_Dhl)); 
// as_rs2_match: assert property (type_alu_r_instr_Dhl && ctrl.inst_val_Dhl |-> (rs2 == dpath.rf_raddr1_Dhl)); 

// Assert that rd in W stage matches rd of the decoded instruction for the same transid
// as__ir_rf_trans_transid_data_integrity_rd: assert property (|ir_rf_trans_transid_sampled && ir_rf_trans_transid_response |-> (rf_waddr_Whl_reg == ir_rf_trans_transid_data_model_rd));

endmodule